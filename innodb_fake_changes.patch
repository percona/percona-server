# name       : innodb_fake_changes.patch
# introduced : 5.5.12
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
diff -ruN a/storage/innobase/btr/btr0cur.c b/storage/innobase/btr/btr0cur.c
--- a/storage/innobase/btr/btr0cur.c	2011-06-01 21:04:26.346416429 +0900
+++ b/storage/innobase/btr/btr0cur.c	2011-06-01 21:04:53.718415294 +0900
@@ -1167,6 +1167,11 @@
 	rec_t*		rec;
 	roll_ptr_t	roll_ptr;
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip LOCK, UNDO */
+		return(DB_SUCCESS);
+	}
+
 	/* Check if we have to wait for a lock: enqueue an explicit lock
 	request if yes */
 
@@ -1298,7 +1303,7 @@
 	}
 #endif /* UNIV_DEBUG */
 
-	ut_ad(mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
 	max_size = page_get_max_insert_size_after_reorganize(page, 1);
 	leaf = page_is_leaf(page);
 
@@ -1393,6 +1398,12 @@
 		goto fail_err;
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip CHANGE, LOG */
+		*big_rec = big_rec_vec;
+		return(err); /* == DB_SUCCESS */
+	}
+
 	page_cursor = btr_cur_get_page_cur(cursor);
 
 	/* Now, try the insert */
@@ -1535,10 +1546,10 @@
 
 	*big_rec = NULL;
 
-	ut_ad(mtr_memo_contains(mtr,
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr,
 				dict_index_get_lock(btr_cur_get_index(cursor)),
 				MTR_MEMO_X_LOCK));
-	ut_ad(mtr_memo_contains(mtr, btr_cur_get_block(cursor),
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr, btr_cur_get_block(cursor),
 				MTR_MEMO_PAGE_X_FIX));
 
 	/* Try first an optimistic insert; reset the cursor flag: we do not
@@ -1604,6 +1615,16 @@
 		}
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip CHANGE, LOG */
+		if (n_extents > 0) {
+			fil_space_release_free_extents(index->space,
+						       n_reserved);
+		}
+		*big_rec = big_rec_vec;
+		return(DB_SUCCESS);
+	}
+
 	if (dict_index_get_page(index)
 	    == buf_block_get_page_no(btr_cur_get_block(cursor))) {
 
@@ -1660,6 +1681,11 @@
 
 	ut_ad(cursor && update && thr && roll_ptr);
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip LOCK, UNDO */
+		return(DB_SUCCESS);
+	}
+
 	rec = btr_cur_get_rec(cursor);
 	index = cursor->index;
 
@@ -1958,6 +1984,14 @@
 		return(err);
 	}
 
+	if (trx->fake_changes) {
+		/* skip CHANGE, LOG */
+		if (UNIV_LIKELY_NULL(heap)) {
+			mem_heap_free(heap);
+		}
+		return(err); /* == DB_SUCCESS */
+	}
+
 	if (block->is_hashed) {
 		/* The function row_upd_changes_ord_field_binary works only
 		if the update vector was built for a clustered index, we must
@@ -2061,7 +2095,7 @@
 	rec = btr_cur_get_rec(cursor);
 	index = cursor->index;
 	ut_ad(!!page_rec_is_comp(rec) == dict_table_is_comp(index->table));
-	ut_ad(mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
 	/* The insert buffer tree should never be updated in place. */
 	ut_ad(!dict_index_is_ibuf(index));
 
@@ -2171,6 +2205,11 @@
 		goto err_exit;
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip CHANGE, LOG */
+		goto err_exit; /* == DB_SUCCESS */
+	}
+
 	/* Ok, we may do the replacement. Store on the page infimum the
 	explicit locks on rec, before deleting rec (see the comment in
 	btr_cur_pessimistic_update). */
@@ -2321,9 +2360,9 @@
 	rec = btr_cur_get_rec(cursor);
 	index = cursor->index;
 
-	ut_ad(mtr_memo_contains(mtr, dict_index_get_lock(index),
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr, dict_index_get_lock(index),
 				MTR_MEMO_X_LOCK));
-	ut_ad(mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
+	ut_ad((thr && thr_get_trx(thr)->fake_changes) || mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
 #ifdef UNIV_ZIP_DEBUG
 	ut_a(!page_zip || page_zip_validate(page_zip, page));
 #endif /* UNIV_ZIP_DEBUG */
@@ -2411,6 +2450,9 @@
 
 		ut_ad(big_rec_vec == NULL);
 
+		/* fake_changes should not cause undo. so never reaches here */
+		ut_ad(!(trx->fake_changes));
+
 		btr_rec_free_updated_extern_fields(
 			index, rec, page_zip, offsets, update,
 			trx_is_recv(trx) ? RB_RECOVERY : RB_NORMAL, mtr);
@@ -2445,6 +2487,12 @@
 		}
 	}
 
+	if (trx->fake_changes) {
+		/* skip CHANGE, LOG */
+		err = DB_SUCCESS;
+		goto return_after_reservations;
+	}
+
 	/* Store state of explicit locks on rec on the page infimum record,
 	before deleting rec. The page infimum acts as a dummy carrier of the
 	locks, taking care also of lock releases, before we can move the locks
@@ -2746,6 +2794,11 @@
 	ut_ad(dict_index_is_clust(index));
 	ut_ad(!rec_get_deleted_flag(rec, rec_offs_comp(offsets)));
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip LOCK, UNDO, CHANGE, LOG */
+		return(DB_SUCCESS);
+	}
+
 	err = lock_clust_rec_modify_check_and_lock(flags, block,
 						   rec, index, offsets, thr);
 
@@ -2883,6 +2936,11 @@
 	rec_t*		rec;
 	ulint		err;
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		/* skip LOCK, CHANGE, LOG */
+		return(DB_SUCCESS);
+	}
+
 	block = btr_cur_get_block(cursor);
 	rec = btr_cur_get_rec(cursor);
 
diff -ruN a/storage/innobase/handler/ha_innodb.cc b/storage/innobase/handler/ha_innodb.cc
--- a/storage/innobase/handler/ha_innodb.cc	2011-06-01 21:04:26.511385596 +0900
+++ b/storage/innobase/handler/ha_innodb.cc	2011-06-01 21:04:53.723390828 +0900
@@ -484,6 +484,12 @@
   " or 2 (write at commit, flush once per second).",
   NULL, NULL, 1, 0, 2, 0);
 
+static MYSQL_THDVAR_BOOL(fake_changes, PLUGIN_VAR_OPCMDARG,
+  "In the transaction after enabled, UPDATE, INSERT and DELETE only move the cursor to the records "
+  "and do nothing other operations (no changes, no ibuf, no undo, no transaction log) in the transaction. "
+  "ATTENTION: the transaction started after enabled is affected.",
+  NULL, NULL, FALSE);
+
 
 static handler *innobase_create_handler(handlerton *hton,
                                         TABLE_SHARE *table,
@@ -1661,6 +1667,8 @@
 	trx->check_unique_secondary = !thd_test_options(
 		thd, OPTION_RELAXED_UNIQUE_CHECKS);
 
+	trx->fake_changes = THDVAR(thd, fake_changes);
+
 #ifdef EXTENDED_SLOWLOG
 	if (thd_log_slow_verbosity(thd) & SLOG_V_INNODB) {
 		trx->take_stats = TRUE;
@@ -7312,12 +7320,20 @@
 
 	parent_trx = check_trx_exists(thd);
 
+
+	if (parent_trx->fake_changes
+	    && thd_sql_command(thd) != SQLCOM_CREATE_TABLE) {
+		sql_print_error("innodb_fake_changes cannot treat new table during other than CREATE TABLE. (%s)\n", name);
+		DBUG_RETURN(HA_ERR_WRONG_COMMAND);
+	}
+
 	/* In case MySQL calls this in the middle of a SELECT query, release
 	possible adaptive hash latch to avoid deadlocks of threads */
 
 	trx_search_latch_release_if_reserved(parent_trx);
 
 	trx = innobase_trx_allocate(thd);
+	trx->fake_changes = FALSE;
 
 	srv_lower_case_table_names = lower_case_table_names;
 
@@ -7692,6 +7708,7 @@
 /*==============================*/
 {
 	int		error;
+	ibool		fake_changes_reserved = FALSE;
 
 	DBUG_ENTER("ha_innobase::truncate");
 
@@ -7704,10 +7721,21 @@
 		DBUG_RETURN(HA_ERR_CRASHED);
 	}
 
+	if (prebuilt->trx->fake_changes) {
+		/* disable temporally */
+		prebuilt->trx->fake_changes = FALSE;
+		fake_changes_reserved = TRUE;
+	}
+
 	/* Truncate the table in InnoDB */
 
 	error = row_truncate_table_for_mysql(prebuilt->table, prebuilt->trx);
 
+	if (fake_changes_reserved) {
+		prebuilt->trx->fake_changes = TRUE;
+		fake_changes_reserved = FALSE;
+	}
+
 	if (share->ib_table->is_corrupt) {
 		DBUG_RETURN(HA_ERR_CRASHED);
 	}
@@ -7759,6 +7787,7 @@
 	trx_search_latch_release_if_reserved(parent_trx);
 
 	trx = innobase_trx_allocate(thd);
+	trx->fake_changes = FALSE;
 
 	srv_lower_case_table_names = lower_case_table_names;
 
@@ -7848,6 +7877,7 @@
 	trx->mysql_thd = NULL;
 #else
 	trx = innobase_trx_allocate(thd);
+	trx->fake_changes = FALSE;
 #endif
 	row_drop_database_for_mysql(namebuf, trx);
 	my_free(namebuf);
@@ -7955,6 +7985,7 @@
 	trx_search_latch_release_if_reserved(parent_trx);
 
 	trx = innobase_trx_allocate(thd);
+	trx->fake_changes = FALSE;
 
 	error = innobase_rename_table(trx, from, to, TRUE);
 
@@ -12221,6 +12252,7 @@
   MYSQL_SYSVAR(rollback_segments),
   MYSQL_SYSVAR(corrupt_table_action),
   MYSQL_SYSVAR(lazy_drop_table),
+  MYSQL_SYSVAR(fake_changes),
   NULL
 };
 
diff -ruN a/storage/innobase/handler/handler0alter.cc b/storage/innobase/handler/handler0alter.cc
--- a/storage/innobase/handler/handler0alter.cc	2011-04-11 19:44:03.000000000 +0900
+++ b/storage/innobase/handler/handler0alter.cc	2011-06-01 21:04:53.728495636 +0900
@@ -641,6 +641,7 @@
 	ibool		dict_locked	= FALSE;
 	ulint		new_primary;
 	int		error;
+	ulint		should_fake_changes	= FALSE;
 
 	DBUG_ENTER("ha_innobase::add_index");
 	ut_a(table);
@@ -658,11 +659,16 @@
 	/* In case MySQL calls this in the middle of a SELECT query, release
 	possible adaptive hash latch to avoid deadlocks of threads. */
 	trx_search_latch_release_if_reserved(prebuilt->trx);
+	if (prebuilt->trx->fake_changes) {
+		prebuilt->trx->fake_changes = FALSE;
+		should_fake_changes = TRUE;
+	}
 	trx_start_if_not_started(prebuilt->trx);
 
 	/* Create a background transaction for the operations on
 	the data dictionary tables. */
 	trx = innobase_trx_allocate(user_thd);
+	trx->fake_changes = FALSE;
 	trx_start_if_not_started(trx);
 
 	innodb_table = indexed_table
@@ -688,6 +694,9 @@
 		trx_general_rollback_for_mysql(trx, NULL);
 		trx_free_for_mysql(trx);
 		trx_commit_for_mysql(prebuilt->trx);
+		if (should_fake_changes) {
+			prebuilt->trx->fake_changes = TRUE;
+		}
 		DBUG_RETURN(error);
 	}
 
@@ -928,6 +937,9 @@
 	trx_commit_for_mysql(trx);
 	if (prebuilt->trx) {
 		trx_commit_for_mysql(prebuilt->trx);
+		if (should_fake_changes) {
+			prebuilt->trx->fake_changes = TRUE;
+		}
 	}
 
 	if (dict_locked) {
@@ -1175,6 +1187,7 @@
 	/* Create a background transaction for the operations on
 	the data dictionary tables. */
 	trx = innobase_trx_allocate(user_thd);
+	trx->fake_changes = FALSE;
 	trx_start_if_not_started(trx);
 
 	/* Flag this transaction as a dictionary operation, so that
diff -ruN a/storage/innobase/ibuf/ibuf0ibuf.c b/storage/innobase/ibuf/ibuf0ibuf.c
--- a/storage/innobase/ibuf/ibuf0ibuf.c	2011-06-01 21:04:26.529383815 +0900
+++ b/storage/innobase/ibuf/ibuf0ibuf.c	2011-06-01 21:04:53.732416483 +0900
@@ -3507,6 +3507,8 @@
 
 	ut_a(trx_sys_multiple_tablespace_format);
 
+	ut_ad(!(thr_get_trx(thr)->fake_changes));
+
 	do_merge = FALSE;
 
 	/* Perform dirty reads of ibuf->size and ibuf->max_size, to
diff -ruN a/storage/innobase/include/trx0trx.h b/storage/innobase/include/trx0trx.h
--- a/storage/innobase/include/trx0trx.h	2011-06-01 21:04:25.762416618 +0900
+++ b/storage/innobase/include/trx0trx.h	2011-06-01 21:04:53.736387944 +0900
@@ -501,6 +501,7 @@
 					FALSE, one can save CPU time and about
 					150 bytes in the undo log size as then
 					we skip XA steps */
+	ulint		fake_changes;
 	ulint		flush_log_later;/* In 2PC, we hold the
 					prepare_commit mutex across
 					both phases. In that case, we
diff -ruN a/storage/innobase/lock/lock0lock.c b/storage/innobase/lock/lock0lock.c
--- a/storage/innobase/lock/lock0lock.c	2011-06-01 21:04:26.543396960 +0900
+++ b/storage/innobase/lock/lock0lock.c	2011-06-01 21:04:53.739416526 +0900
@@ -3909,6 +3909,10 @@
 
 	trx = thr_get_trx(thr);
 
+	if (trx->fake_changes && mode == LOCK_IX) {
+		mode = LOCK_IS;
+	}
+
 	lock_mutex_enter_kernel();
 
 	/* Look for stronger locks the same trx already has on the table */
@@ -5107,6 +5111,11 @@
 	}
 
 	trx = thr_get_trx(thr);
+
+	if (trx->fake_changes) {
+		return(DB_SUCCESS);
+	}
+
 	next_rec = page_rec_get_next_const(rec);
 	next_rec_heap_no = page_rec_get_heap_no(next_rec);
 
@@ -5275,6 +5284,10 @@
 		return(DB_SUCCESS);
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		return(DB_SUCCESS);
+	}
+
 	heap_no = rec_offs_comp(offsets)
 		? rec_get_heap_no_new(rec)
 		: rec_get_heap_no_old(rec);
@@ -5333,6 +5346,10 @@
 		return(DB_SUCCESS);
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes) {
+		return(DB_SUCCESS);
+	}
+
 	heap_no = page_rec_get_heap_no(rec);
 
 	/* Another transaction cannot have an implicit lock on the record,
@@ -5420,6 +5437,10 @@
 		return(DB_SUCCESS);
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes && mode == LOCK_X) {
+		mode = LOCK_S;
+	}
+
 	heap_no = page_rec_get_heap_no(rec);
 
 	lock_mutex_enter_kernel();
@@ -5496,6 +5517,10 @@
 		return(DB_SUCCESS);
 	}
 
+	if (thr && thr_get_trx(thr)->fake_changes && mode == LOCK_X) {
+		mode = LOCK_S;
+	}
+
 	heap_no = page_rec_get_heap_no(rec);
 
 	lock_mutex_enter_kernel();
diff -ruN a/storage/innobase/que/que0que.c b/storage/innobase/que/que0que.c
--- a/storage/innobase/que/que0que.c	2011-06-01 21:04:25.553416889 +0900
+++ b/storage/innobase/que/que0que.c	2011-06-01 21:04:53.743419001 +0900
@@ -1417,6 +1417,12 @@
 
 	ut_a(trx->error_state == DB_SUCCESS);
 
+	if (trx->fake_changes) {
+		/* fake_changes should not access to system tables */
+		fprintf(stderr, "InnoDB: ERROR: innodb_fake_changes tried to access to system tables.\n");
+		return(DB_ERROR);
+	}
+
 	if (reserve_dict_mutex) {
 		mutex_enter(&dict_sys->mutex);
 	}
diff -ruN a/storage/innobase/row/row0ins.c b/storage/innobase/row/row0ins.c
--- a/storage/innobase/row/row0ins.c	2011-06-01 21:04:26.099449453 +0900
+++ b/storage/innobase/row/row0ins.c	2011-06-01 21:04:53.746383371 +0900
@@ -1499,6 +1499,11 @@
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
 	}
+
+	if (trx->fake_changes) {
+		err = DB_SUCCESS;
+	}
+
 	return(err);
 }
 
@@ -2004,7 +2009,7 @@
 	}
 
 	btr_cur_search_to_nth_level(index, 0, entry, PAGE_CUR_LE,
-				    search_mode,
+				    thr_get_trx(thr)->fake_changes ? BTR_SEARCH_LEAF : search_mode,
 				    &cursor, 0, __FILE__, __LINE__, &mtr);
 
 	if (cursor.flag == BTR_CUR_INSERT_TO_IBUF) {
@@ -2065,7 +2070,7 @@
 
 			btr_cur_search_to_nth_level(index, 0, entry,
 						    PAGE_CUR_LE,
-						    mode | BTR_INSERT,
+						    thr_get_trx(thr)->fake_changes ? BTR_SEARCH_LEAF : (mode | BTR_INSERT),
 						    &cursor, 0,
 						    __FILE__, __LINE__, &mtr);
 		}
@@ -2119,6 +2124,22 @@
 	if (UNIV_LIKELY_NULL(big_rec)) {
 		rec_t*	rec;
 		ulint*	offsets;
+
+		if (thr_get_trx(thr)->fake_changes) {
+			/* skip store extern */
+			if (modify) {
+				dtuple_big_rec_free(big_rec);
+			} else {
+				dtuple_convert_back_big_rec(index, entry, big_rec);
+			}
+
+			if (UNIV_LIKELY_NULL(heap)) {
+				mem_heap_free(heap);
+			}
+
+			return(err);
+		}
+
 		mtr_start(&mtr);
 
 		btr_cur_search_to_nth_level(index, 0, entry, PAGE_CUR_LE,
diff -ruN a/storage/innobase/row/row0mysql.c b/storage/innobase/row/row0mysql.c
--- a/storage/innobase/row/row0mysql.c	2011-06-01 21:04:26.287385626 +0900
+++ b/storage/innobase/row/row0mysql.c	2011-06-01 21:04:53.749372325 +0900
@@ -1248,6 +1248,7 @@
 		prebuilt->table->stat_n_rows--;
 	}
 
+	if (!(trx->fake_changes))
 	row_update_statistics_if_needed(prebuilt->table);
 	trx->op_info = "";
 
@@ -1508,6 +1509,7 @@
 	that changes indexed columns, UPDATEs that change only non-indexed
 	columns would not affect statistics. */
 	if (node->is_delete || !(node->cmpl_info & UPD_NODE_NO_ORD_CHANGE)) {
+		if (!(trx->fake_changes))
 		row_update_statistics_if_needed(prebuilt->table);
 	}
 
@@ -1726,6 +1728,7 @@
 		srv_n_rows_updated++;
 	}
 
+	if (!(trx->fake_changes))
 	row_update_statistics_if_needed(table);
 
 	return(err);
diff -ruN a/storage/innobase/row/row0upd.c b/storage/innobase/row/row0upd.c
--- a/storage/innobase/row/row0upd.c	2011-06-01 21:04:25.588384975 +0900
+++ b/storage/innobase/row/row0upd.c	2011-06-01 21:04:53.753385366 +0900
@@ -1603,7 +1603,8 @@
 		mode |= BTR_DELETE_MARK;
 	}
 
-	search_result = row_search_index_entry(index, entry, mode,
+	search_result = row_search_index_entry(index, entry,
+					       trx->fake_changes ? BTR_SEARCH_LEAF : mode,
 					       &pcur, &mtr);
 
 	btr_cur = btr_pcur_get_btr_cur(&pcur);
@@ -1850,9 +1851,11 @@
 		the previous invocation of this function. Mark the
 		off-page columns in the entry inherited. */
 
+		if (!(trx->fake_changes)) {
 		change_ownership = row_upd_clust_rec_by_insert_inherit(
 			NULL, NULL, entry, node->update);
 		ut_a(change_ownership);
+		}
 		/* fall through */
 	case UPD_NODE_INSERT_CLUSTERED:
 		/* A lock wait occurred in row_ins_index_entry() in
@@ -1882,7 +1885,7 @@
 		delete-marked old record, mark them disowned by the
 		old record and owned by the new entry. */
 
-		if (rec_offs_any_extern(offsets)) {
+		if (rec_offs_any_extern(offsets) && !(trx->fake_changes)) {
 			change_ownership = row_upd_clust_rec_by_insert_inherit(
 				rec, offsets, entry, node->update);
 
@@ -2012,7 +2015,8 @@
 	the same transaction do not modify the record in the meantime.
 	Therefore we can assert that the restoration of the cursor succeeds. */
 
-	ut_a(btr_pcur_restore_position(BTR_MODIFY_TREE, pcur, mtr));
+	ut_a(btr_pcur_restore_position(thr_get_trx(thr)->fake_changes ? BTR_SEARCH_LEAF : BTR_MODIFY_TREE,
+				       pcur, mtr));
 
 	ut_ad(!rec_get_deleted_flag(btr_pcur_get_rec(pcur),
 				    dict_table_is_comp(index->table)));
@@ -2022,7 +2026,8 @@
 					 node->cmpl_info, thr, mtr);
 	mtr_commit(mtr);
 
-	if (err == DB_SUCCESS && big_rec) {
+	/* skip store extern for fake_changes */
+	if (err == DB_SUCCESS && big_rec && !(thr_get_trx(thr)->fake_changes)) {
 		ulint		offsets_[REC_OFFS_NORMAL_SIZE];
 		rec_t*		rec;
 		rec_offs_init(offsets_);
@@ -2146,7 +2151,8 @@
 
 	ut_a(pcur->rel_pos == BTR_PCUR_ON);
 
-	success = btr_pcur_restore_position(BTR_MODIFY_LEAF, pcur, mtr);
+	success = btr_pcur_restore_position(thr_get_trx(thr)->fake_changes ? BTR_SEARCH_LEAF : BTR_MODIFY_LEAF,
+					    pcur, mtr);
 
 	if (!success) {
 		err = DB_RECORD_NOT_FOUND;
diff -ruN a/storage/innobase/trx/trx0trx.c b/storage/innobase/trx/trx0trx.c
--- a/storage/innobase/trx/trx0trx.c	2011-06-01 21:04:26.411537237 +0900
+++ b/storage/innobase/trx/trx0trx.c	2011-06-01 21:04:53.756415956 +0900
@@ -118,6 +118,8 @@
 
 	trx->support_xa = TRUE;
 
+	trx->fake_changes = FALSE;
+
 	trx->check_foreigns = TRUE;
 	trx->check_unique_secondary = TRUE;
 
