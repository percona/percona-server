# name       : innodb_show_status.patch
# introduced : 11 or before
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
diff -ruN a/storage/innobase/buf/buf0buf.c b/storage/innobase/buf/buf0buf.c
--- a/storage/innobase/buf/buf0buf.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/buf/buf0buf.c	2010-12-03 15:07:31.786968193 +0900
@@ -4812,14 +4812,16 @@
 	buf_flush_list_mutex_enter(buf_pool);
 
 	fprintf(file,
-		"Buffer pool size   %lu\n"
-		"Free buffers       %lu\n"
-		"Database pages     %lu\n"
-		"Old database pages %lu\n"
-		"Modified db pages  %lu\n"
+		"Buffer pool size        %lu\n"
+		"Buffer pool size, bytes %lu\n"
+		"Free buffers            %lu\n"
+		"Database pages          %lu\n"
+		"Old database pages      %lu\n"
+		"Modified db pages       %lu\n"
 		"Pending reads %lu\n"
 		"Pending writes: LRU %lu, flush list %lu, single page %lu\n",
 		(ulong) buf_pool->curr_size,
+		(ulong) buf_pool->curr_size * UNIV_PAGE_SIZE,
 		(ulong) UT_LIST_GET_LEN(buf_pool->free),
 		(ulong) UT_LIST_GET_LEN(buf_pool->LRU),
 		(ulong) buf_pool->LRU_old_len,
diff -ruN a/storage/innobase/fil/fil0fil.c b/storage/innobase/fil/fil0fil.c
--- a/storage/innobase/fil/fil0fil.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/fil/fil0fil.c	2010-12-03 15:07:31.790357112 +0900
@@ -4858,3 +4858,30 @@
 
 	fil_system = NULL;
 }
+
+/*************************************************************************
+Return local hash table informations. */
+
+ulint
+fil_system_hash_cells(void)
+/*=======================*/
+{
+       if (fil_system) {
+               return (fil_system->spaces->n_cells
+                       + fil_system->name_hash->n_cells);
+       } else {
+               return 0;
+       }
+}
+
+ulint
+fil_system_hash_nodes(void)
+/*=======================*/
+{
+       if (fil_system) {
+               return (UT_LIST_GET_LEN(fil_system->space_list)
+                       * (sizeof(fil_space_t) + MEM_BLOCK_HEADER_SIZE));
+       } else {
+               return 0;
+       }
+}
diff -ruN a/storage/innobase/handler/ha_innodb.cc b/storage/innobase/handler/ha_innodb.cc
--- a/storage/innobase/handler/ha_innodb.cc	2010-12-03 15:06:58.727955654 +0900
+++ b/storage/innobase/handler/ha_innodb.cc	2010-12-03 15:07:31.799376984 +0900
@@ -10984,6 +10984,16 @@
   "Force InnoDB to not use next-key locking, to use only row-level locking.",
   NULL, NULL, FALSE);
 
+static MYSQL_SYSVAR_ULONG(show_verbose_locks, srv_show_verbose_locks,
+  PLUGIN_VAR_OPCMDARG,
+  "Whether to show records locked in SHOW INNODB STATUS.",
+  NULL, NULL, 0, 0, 1, 0);
+
+static MYSQL_SYSVAR_ULONG(show_locks_held, srv_show_locks_held,
+  PLUGIN_VAR_RQCMDARG,
+  "Number of locks held to print for each InnoDB transaction in SHOW INNODB STATUS.",
+  NULL, NULL, 10, 0, 1000, 0);
+
 #ifdef UNIV_LOG_ARCHIVE
 static MYSQL_SYSVAR_STR(log_arch_dir, innobase_log_arch_dir,
   PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_READONLY,
@@ -11171,7 +11181,7 @@
 
 static MYSQL_SYSVAR_STR(version, innodb_version_str,
   PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_READONLY,
-  "InnoDB version", NULL, NULL, INNODB_VERSION_STR);
+  "Percona-InnoDB-plugin version", NULL, NULL, INNODB_VERSION_STR);
 
 static MYSQL_SYSVAR_BOOL(use_sys_malloc, srv_use_sys_malloc,
   PLUGIN_VAR_NOCMDARG | PLUGIN_VAR_READONLY,
@@ -11256,6 +11266,8 @@
   MYSQL_SYSVAR(thread_concurrency),
   MYSQL_SYSVAR(thread_sleep_delay),
   MYSQL_SYSVAR(autoinc_lock_mode),
+  MYSQL_SYSVAR(show_verbose_locks),
+  MYSQL_SYSVAR(show_locks_held),
   MYSQL_SYSVAR(version),
   MYSQL_SYSVAR(use_sys_malloc),
   MYSQL_SYSVAR(use_native_aio),
diff -ruN a/storage/innobase/handler/innodb_patch_info.h b/storage/innobase/handler/innodb_patch_info.h
--- a/storage/innobase/handler/innodb_patch_info.h	2010-12-03 15:06:58.745967863 +0900
+++ b/storage/innobase/handler/innodb_patch_info.h	2010-12-03 15:07:31.811024360 +0900
@@ -24,5 +24,6 @@
        const char *link;
 }innodb_enhancements[] = {
 {"xtradb_show_enhancements","I_S.XTRADB_ENHANCEMENTS","","http://www.percona.com/docs/wiki/percona-xtradb"},
+{"innodb_show_status","Improvements to SHOW INNODB STATUS","Memory information and lock info fixes","http://www.percona.com/docs/wiki/percona-xtradb"},
 {NULL, NULL, NULL, NULL}
 };
diff -ruN a/storage/innobase/include/fil0fil.h b/storage/innobase/include/fil0fil.h
--- a/storage/innobase/include/fil0fil.h	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/include/fil0fil.h	2010-12-03 15:07:31.812028575 +0900
@@ -726,6 +726,17 @@
 /*============================*/
 	ulint		id);	/*!< in: space id */
 
+/*************************************************************************
+Return local hash table informations. */
+
+ulint
+fil_system_hash_cells(void);
+/*========================*/
+
+ulint
+fil_system_hash_nodes(void);
+/*========================*/
+
 typedef	struct fil_space_struct	fil_space_t;
 
 #endif
diff -ruN a/storage/innobase/include/srv0srv.h b/storage/innobase/include/srv0srv.h
--- a/storage/innobase/include/srv0srv.h	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/include/srv0srv.h	2010-12-03 15:07:31.813958103 +0900
@@ -145,6 +145,9 @@
 extern char	srv_adaptive_flushing;
 
 
+extern ulint    srv_show_locks_held;
+extern ulint    srv_show_verbose_locks;
+
 /* The sort order table of the MySQL latin1_swedish_ci character set
 collation */
 extern const byte*	srv_latin1_ordering;
diff -ruN a/storage/innobase/include/thr0loc.h b/storage/innobase/include/thr0loc.h
--- a/storage/innobase/include/thr0loc.h	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/include/thr0loc.h	2010-12-03 15:07:31.815081509 +0900
@@ -83,6 +83,17 @@
 thr_local_get_in_ibuf_field(void);
 /*=============================*/
 
+/*************************************************************************
+Return local hash table informations. */
+
+ulint
+thr_local_hash_cells(void);
+/*=======================*/
+
+ulint
+thr_local_hash_nodes(void);
+/*=======================*/
+
 #ifndef UNIV_NONINL
 #include "thr0loc.ic"
 #endif
diff -ruN a/storage/innobase/lock/lock0lock.c b/storage/innobase/lock/lock0lock.c
--- a/storage/innobase/lock/lock0lock.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/lock/lock0lock.c	2010-12-03 15:07:31.819023998 +0900
@@ -4302,6 +4302,7 @@
 
 	putc('\n', file);
 
+	if ( srv_show_verbose_locks ) {
 	block = buf_page_try_get(space, page_no, &mtr);
 
 	for (i = 0; i < lock_rec_get_n_bits(lock); ++i) {
@@ -4328,6 +4329,7 @@
 
 		putc('\n', file);
 	}
+	}
 
 	mtr_commit(&mtr);
 	if (UNIV_LIKELY_NULL(heap)) {
@@ -4511,7 +4513,7 @@
 		}
 	}
 
-	if (!srv_print_innodb_lock_monitor) {
+        if (!srv_print_innodb_lock_monitor && !srv_show_locks_held) {
 		nth_trx++;
 		goto loop;
 	}
@@ -4583,8 +4585,8 @@
 
 	nth_lock++;
 
-	if (nth_lock >= 10) {
-		fputs("10 LOCKS PRINTED FOR THIS TRX:"
+	if (nth_lock >= srv_show_locks_held) {
+		fputs("TOO MANY LOCKS PRINTED FOR THIS TRX:"
 		      " SUPPRESSING FURTHER PRINTS\n",
 		      file);
 
diff -ruN a/storage/innobase/srv/srv0srv.c b/storage/innobase/srv/srv0srv.c
--- a/storage/innobase/srv/srv0srv.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/srv/srv0srv.c	2010-12-03 15:07:31.824022673 +0900
@@ -193,6 +193,9 @@
 the checkpoints. */
 UNIV_INTERN char	srv_adaptive_flushing	= TRUE;
 
+UNIV_INTERN ulint	srv_show_locks_held	= 10;
+UNIV_INTERN ulint	srv_show_verbose_locks	= 0;
+
 /** Maximum number of times allowed to conditionally acquire
 mutex before switching to blocking wait on the mutex */
 #define MAX_MUTEX_NOWAIT	20
@@ -1787,6 +1790,13 @@
 	ulint	n_reserved;
 	ibool	ret;
 
+	ulint	btr_search_sys_subtotal;
+	ulint	lock_sys_subtotal;
+	ulint	recv_sys_subtotal;
+
+	ulint	i;
+	trx_t*	trx;
+
 	mutex_enter(&srv_innodb_monitor_mutex);
 
 	current_time = time(NULL);
@@ -1835,31 +1845,6 @@
 
 	mutex_exit(&dict_foreign_err_mutex);
 
-	/* Only if lock_print_info_summary proceeds correctly,
-	before we call the lock_print_info_all_transactions
-	to print all the lock information. */
-	ret = lock_print_info_summary(file, nowait);
-
-	if (ret) {
-		if (trx_start) {
-			long	t = ftell(file);
-			if (t < 0) {
-				*trx_start = ULINT_UNDEFINED;
-			} else {
-				*trx_start = (ulint) t;
-			}
-		}
-		lock_print_info_all_transactions(file);
-		if (trx_end) {
-			long	t = ftell(file);
-			if (t < 0) {
-				*trx_end = ULINT_UNDEFINED;
-			} else {
-				*trx_end = (ulint) t;
-			}
-		}
-	}
-
 	fputs("--------\n"
 	      "FILE I/O\n"
 	      "--------\n", file);
@@ -1890,10 +1875,84 @@
 	      "BUFFER POOL AND MEMORY\n"
 	      "----------------------\n", file);
 	fprintf(file,
-		"Total memory allocated " ULINTPF
-		"; in additional pool allocated " ULINTPF "\n",
-		ut_total_allocated_memory,
-		mem_pool_get_reserved(mem_comm_pool));
+			"Total memory allocated " ULINTPF
+			"; in additional pool allocated " ULINTPF "\n",
+			ut_total_allocated_memory,
+			mem_pool_get_reserved(mem_comm_pool));
+	/* Calcurate reserved memories */
+	if (btr_search_sys && btr_search_sys->hash_index->heap) {
+		btr_search_sys_subtotal = mem_heap_get_size(btr_search_sys->hash_index->heap);
+	} else {
+		btr_search_sys_subtotal = 0;
+		for (i=0; i < btr_search_sys->hash_index->n_mutexes; i++) {
+			btr_search_sys_subtotal += mem_heap_get_size(btr_search_sys->hash_index->heaps[i]);
+		}
+	}
+
+	lock_sys_subtotal = 0;
+	if (trx_sys) {
+		mutex_enter(&kernel_mutex);
+		trx = UT_LIST_GET_FIRST(trx_sys->mysql_trx_list);
+		while (trx) {
+			lock_sys_subtotal += ((trx->lock_heap) ? mem_heap_get_size(trx->lock_heap) : 0);
+			trx = UT_LIST_GET_NEXT(mysql_trx_list, trx);
+		}
+		mutex_exit(&kernel_mutex);
+	}
+
+	recv_sys_subtotal = ((recv_sys && recv_sys->addr_hash)
+			? mem_heap_get_size(recv_sys->heap) : 0);
+
+	fprintf(file,
+			"Internal hash tables (constant factor + variable factor)\n"
+			"    Adaptive hash index %lu \t(%lu + %lu)\n"
+			"    Page hash           %lu (buffer pool 0 only)\n"
+			"    Dictionary cache    %lu \t(%lu + %lu)\n"
+			"    File system         %lu \t(%lu + %lu)\n"
+			"    Lock system         %lu \t(%lu + %lu)\n"
+			"    Recovery system     %lu \t(%lu + %lu)\n"
+			"    Threads             %lu \t(%lu + %lu)\n",
+
+			(ulong) (btr_search_sys
+				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0)
+			+ btr_search_sys_subtotal,
+			(ulong) (btr_search_sys
+				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0),
+			(ulong) btr_search_sys_subtotal,
+
+			(ulong) (buf_pool_from_array(0)->page_hash->n_cells * sizeof(hash_cell_t)),
+
+			(ulong) (dict_sys ? ((dict_sys->table_hash->n_cells
+						+ dict_sys->table_id_hash->n_cells
+						) * sizeof(hash_cell_t)
+					+ dict_sys->size) : 0),
+			(ulong) (dict_sys ? ((dict_sys->table_hash->n_cells
+							+ dict_sys->table_id_hash->n_cells
+							) * sizeof(hash_cell_t)) : 0),
+			(ulong) (dict_sys ? (dict_sys->size) : 0),
+
+			(ulong) (fil_system_hash_cells() * sizeof(hash_cell_t)
+					+ fil_system_hash_nodes()),
+			(ulong) (fil_system_hash_cells() * sizeof(hash_cell_t)),
+			(ulong) fil_system_hash_nodes(),
+
+			(ulong) ((lock_sys ? (lock_sys->rec_hash->n_cells * sizeof(hash_cell_t)) : 0)
+					+ lock_sys_subtotal),
+			(ulong) (lock_sys ? (lock_sys->rec_hash->n_cells * sizeof(hash_cell_t)) : 0),
+			(ulong) lock_sys_subtotal,
+
+			(ulong) (((recv_sys && recv_sys->addr_hash)
+						? (recv_sys->addr_hash->n_cells * sizeof(hash_cell_t)) : 0)
+					+ recv_sys_subtotal),
+			(ulong) ((recv_sys && recv_sys->addr_hash)
+					? (recv_sys->addr_hash->n_cells * sizeof(hash_cell_t)) : 0),
+			(ulong) recv_sys_subtotal,
+
+			(ulong) (thr_local_hash_cells() * sizeof(hash_cell_t)
+					+ thr_local_hash_nodes()),
+			(ulong) (thr_local_hash_cells() * sizeof(hash_cell_t)),
+			(ulong) thr_local_hash_nodes());
+
 	fprintf(file, "Dictionary memory allocated " ULINTPF "\n",
 		dict_sys->size);
 
@@ -1952,6 +2011,31 @@
 	srv_n_rows_deleted_old = srv_n_rows_deleted;
 	srv_n_rows_read_old = srv_n_rows_read;
 
+	/* Only if lock_print_info_summary proceeds correctly,
+	before we call the lock_print_info_all_transactions
+	to print all the lock information. */
+	ret = lock_print_info_summary(file, nowait);
+
+	if (ret) {
+		if (trx_start) {
+			long	t = ftell(file);
+			if (t < 0) {
+				*trx_start = ULINT_UNDEFINED;
+			} else {
+				*trx_start = (ulint) t;
+			}
+		}
+		lock_print_info_all_transactions(file);
+		if (trx_end) {
+			long	t = ftell(file);
+			if (t < 0) {
+				*trx_end = ULINT_UNDEFINED;
+			} else {
+				*trx_end = (ulint) t;
+			}
+		}
+	}
+
 	fputs("----------------------------\n"
 	      "END OF INNODB MONITOR OUTPUT\n"
 	      "============================\n", file);
diff -ruN a/storage/innobase/sync/sync0arr.c b/storage/innobase/sync/sync0arr.c
--- a/storage/innobase/sync/sync0arr.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/sync/sync0arr.c	2010-12-03 15:07:31.826041368 +0900
@@ -477,7 +477,7 @@
 
 	fprintf(file,
 		"--Thread %lu has waited at %s line %lu"
-		" for %.2f seconds the semaphore:\n",
+		" for %#.5g seconds the semaphore:\n",
 		(ulong) os_thread_pf(cell->thread), cell->file,
 		(ulong) cell->line,
 		difftime(time(NULL), cell->reservation_time));
diff -ruN a/storage/innobase/thr/thr0loc.c b/storage/innobase/thr/thr0loc.c
--- a/storage/innobase/thr/thr0loc.c	2010-11-03 07:01:13.000000000 +0900
+++ b/storage/innobase/thr/thr0loc.c	2010-12-03 15:07:31.828023915 +0900
@@ -49,6 +49,7 @@
 
 /** The hash table. The module is not yet initialized when it is NULL. */
 static hash_table_t*	thr_local_hash	= NULL;
+ulint		thr_local_hash_n_nodes = 0;
 
 /** Thread local data */
 typedef struct thr_local_struct thr_local_t;
@@ -221,6 +222,7 @@
 		    os_thread_pf(os_thread_get_curr_id()),
 		    local);
 
+	thr_local_hash_n_nodes++;
 	mutex_exit(&thr_local_mutex);
 }
 
@@ -249,6 +251,7 @@
 
 	HASH_DELETE(thr_local_t, hash, thr_local_hash,
 		    os_thread_pf(id), local);
+	thr_local_hash_n_nodes--;
 
 	mutex_exit(&thr_local_mutex);
 
@@ -305,3 +308,29 @@
 	hash_table_free(thr_local_hash);
 	thr_local_hash = NULL;
 }
+
+/*************************************************************************
+Return local hash table informations. */
+
+ulint
+thr_local_hash_cells(void)
+/*======================*/
+{
+	if (thr_local_hash) {
+		return (thr_local_hash->n_cells);
+	} else {
+		return 0;
+	}
+}
+
+ulint
+thr_local_hash_nodes(void)
+/*======================*/
+{
+	if (thr_local_hash) {
+		return (thr_local_hash_n_nodes
+			* (sizeof(thr_local_t) + MEM_BLOCK_HEADER_SIZE));
+	} else {
+		return 0;
+	}
+}
