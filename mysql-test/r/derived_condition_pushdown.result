CREATE TABLE t0 (
i0 INTEGER
);
INSERT INTO t0 VALUES (0),(1),(2),(3),(4);
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER, f3 INTEGER,
KEY(f1), KEY(f1,f2), KEY(f3));
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1 VALUES (NULL, 1, 2);
INSERT INTO t1 VALUES (NULL, 1, 3);
SET optimizer_switch="derived_merge=off,derived_condition_pushdown=on";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt WHERE f1 > 2;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > 2)  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt WHERE f1 > 2;
f1	f2
3	33
3	33
4	44
4	44
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt
WHERE f1 < 3 and f2 > 11;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 < 3) and (t1.f2 > 11))  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt
WHERE f1 < 3 and f2 > 11;
f1	f2
2	22
2	22
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 2 and f2 < 25 and f3 > 200;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f2 < 25) and (t1.f3 > 200))  (cost=*** rows=***)
            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 2 and f2 < 25 and f3 > 200;
f1	f2	f3
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 3 and f2 < 50 or f3 > 200;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((t1.f1 > 3) and (t1.f2 < 50)) or (t1.f3 > 200))  (cost=*** rows=***)
            -> Table scan on t1  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 3 and f2 < 50 or f3 > 200;
f1	f2	f3
2	22	222
3	33	333
4	44	444
2	22	222
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT t1.f2 as f2, dt.f1 as f1, dt.f3 as f3 FROM t1,
(SELECT f1, f2, f3 FROM t1) as dt
WHERE (dt.f1 = 6) or( t1.f2 = 50 and dt.f3 = 200);
EXPLAIN
-> Filter: ((dt.f1 = 6) or ((dt.f3 = 200) and (t1.f2 = 50)))  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Index scan on t1 using f1_2  (cost=*** rows=***)
        -> Hash
            -> Filter: ((dt.f1 = 6) or (dt.f3 = 200))  (cost=*** rows=***)
                -> Table scan on dt  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

SELECT t1.f2 as f2, dt.f1 as f1, dt.f3 as f3 FROM t1,
(SELECT f1, f2, f3 FROM t1) as dt
WHERE (dt.f1 = 6) or( t1.f2 = 50 and dt.f3 = 200);
f2	f1	f3
EXPLAIN FORMAT=tree SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f2 < 50)  (cost=*** rows=***)
                -> Index range scan on t1 using f1, with index condition: (t1.f1 > 3)  (cost=*** rows=***)
    -> Hash
        -> Filter: (t0.i0 > 3)  (cost=*** rows=***)
            -> Table scan on t0  (cost=*** rows=***)

SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
f1	f2	f3	i0
4	44	444	4
4	44	444	4
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT * FROM t1) as dt1) as dt2
WHERE f1 > 3 and f2 < 50 and f3 > 200;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f2 < 50) and (t1.f3 > 200))  (cost=*** rows=***)
                    -> Index range scan on t1 using f1, with index condition: (t1.f1 > 3)  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT * FROM t1) as dt1) as dt2
WHERE f1 > 3 and f2 < 50 and f3 > 200;
f1	f2	f3
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f2 < 35) and ((t1.f1 + t1.f3) > 300))  (cost=*** rows=***)
            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300;
f1	f2	f3
3	33	333
3	33	333
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) or (f1+f3) > 300 or (f1 < 2);
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((t1.f1 > 2) and (t1.f2 < 35)) or ((t1.f1 + t1.f3) > 300) or (t1.f1 < 2))  (cost=*** rows=***)
            -> Table scan on t1  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) or (f1+f3) > 300 or (f1 < 2);
f1	f2	f3
0	0	0
1	11	111
3	33	333
4	44	444
0	0	0
1	11	111
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300
and (f3 < 400);
EXPLAIN
-> Filter: ((dt1.f1 + dt2.f3) > 300)  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Table scan on dt2  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f3 < 400)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f3  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: ((t1.f1 > 2) and (t1.f2 < 35))  (cost=*** rows=***)
                        -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300
and (f3 < 400);
f1	f2	f3
3	33	333
3	33	333
3	33	333
3	33	333
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2) as dt3
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 200 and (f3 < 300);
EXPLAIN
-> Table scan on dt3  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((dt1.f1 + dt2.f3) > 200)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on dt2  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Filter: (t1.f3 < 300)  (cost=*** rows=***)
                            -> Covering index range scan on t1 using f3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on dt1  (cost=*** rows=***)
                        -> Materialize  (cost=*** rows=***)
                            -> Filter: ((t1.f1 > 2) and (t1.f2 < 35))  (cost=*** rows=***)
                                -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2) as dt3
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 200 and (f3 < 300);
f1	f2	f3
3	33	222
3	33	222
3	33	222
3	33	222
EXPLAIN FORMAT=tree SELECT i, j, k FROM (SELECT f1 as i, f2 as j, f2 as k FROM t1) as dt
WHERE i > 1 and i+j > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 > 1) and ((t1.f1 + t1.f2) > 40))  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT i, j, k FROM (SELECT f1 as i, f2 as j, f2 as k FROM t1) as dt
WHERE i > 1 and i+j > 40;
i	j	k
4	44	44
4	44	44
EXPLAIN FORMAT=tree SELECT i, j, k
FROM (SELECT l as i, m as j, n as k
FROM (SELECT f1 as l, f2 as m, f3 as n
FROM t1) as dt1 ) as dt2
WHERE i > 1 and i+j > 40;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f1 + t1.f2) > 40)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1, with index condition: (t1.f1 > 1)  (cost=*** rows=***)

SELECT i, j, k
FROM (SELECT l as i, m as j, n as k
FROM (SELECT f1 as l, f2 as m, f3 as n
FROM t1) as dt1 ) as dt2
WHERE i > 1 and i+j > 40;
i	j	k
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT i, j, l, m, n
FROM (SELECT f1 as i, f2 as j FROM t1 ) as dt1 ,
(SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt2
WHERE i > 1 and i+j > 40 and m < 20 and m+i > 20;
EXPLAIN
-> Filter: ((dt2.m + dt1.i) > 20)  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f1 > 1) and ((t1.f1 + t1.f2) > 40))  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt2  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: (t1.f2 < 20)  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

SELECT i, j, l, m, n
FROM (SELECT f1 as i, f2 as j FROM t1 ) as dt1 ,
(SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt2
WHERE i > 1 and i+j > 40 and m < 20 and m+i > 20;
i	j	l	m	n
EXPLAIN FORMAT=tree SELECT * FROM
(SELECT (i+j) AS g, f1 FROM
(SELECT (f1+f2) AS i, (f1-f2) AS j FROM
(SELECT f1+10 AS f1, f2+10 AS f2 FROM t1) AS dt0)
AS dt1,
(SELECT f1, f2 FROM t1) AS dt2) AS dt3 WHERE g > 26 and g+f1 > 31;
EXPLAIN
-> Table scan on dt3  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((dt1.i + dt1.j) + dt2.f1) > 31)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on dt2  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Index scan on t1 using f1_2  (cost=*** rows=***)
                -> Hash
                    -> Table scan on dt1  (cost=*** rows=***)
                        -> Materialize  (cost=*** rows=***)
                            -> Table scan on dt0  (cost=*** rows=***)
                                -> Materialize  (cost=*** rows=***)
                                    -> Filter: ((((t1.f1 + 10) + (t1.f2 + 10)) + ((t1.f1 + 10) - (t1.f2 + 10))) > 26)  (cost=*** rows=***)
                                        -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM
(SELECT (i+j) AS g, f1 FROM
(SELECT (f1+f2) AS i, (f1-f2) AS j FROM
(SELECT f1+10 AS f1, f2+10 AS f2 FROM t1) AS dt0)
AS dt1,
(SELECT f1, f2 FROM t1) AS dt2) AS dt3 WHERE g > 26 and g+f1 > 31;
g	f1
28	4
28	4
28	4
28	4
EXPLAIN FORMAT=tree SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+10) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((((t1.f1 + t1.f2) + 3) > 20) and ((((t1.f1 + t1.f2) + 3) + ((t1.f3 + 10) + 4)) > 10))  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+10) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ;
l	m
27	236
39	347
51	458
27	236
39	347
51	458
EXPLAIN FORMAT=tree SELECT i FROM (SELECT f1 FROM t1) as dt(i) WHERE i > 10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1  (cost=*** rows=***)

SELECT i FROM (SELECT f1 FROM t1) as dt(i) WHERE i > 10;
i
EXPLAIN FORMAT=tree SELECT m FROM (SELECT k+2 as l
FROM (SELECT f1+f2 as j
FROM t1) as dt1(k)) as dt(m)
WHERE m > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (((t1.f1 + t1.f2) + 2) > 30)  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT m FROM (SELECT k+2 as l
FROM (SELECT f1+f2 as j
FROM t1) as dt1(k)) as dt(m)
WHERE m > 30;
m
38
38
50
50
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
            -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3;
f1
4
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2, SUM(f3) FROM t1 GROUP BY f1,f2) as dt
WHERE f1+f2 > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Group aggregate: sum(t1.f3)  (cost=*** rows=***)
            -> Filter: ((t1.f1 + t1.f2) > 30)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2, SUM(f3) FROM t1 GROUP BY f1,f2) as dt
WHERE f1+f2 > 30;
f1
3
4
EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1 WITH ROLLUP) as dt
WHERE f1 IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (rollup_group_item(t1.f1,0) is null)  (cost=*** rows=***)
            -> Group aggregate with rollup: sum(t1.f2)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1
FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1 WITH ROLLUP) as dt
WHERE f1 IS NULL;
f1
NULL
NULL
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE j+sum > 50 OR
j IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((rollup_group_item(t1.f1,0) + rollup_sum_switcher(sum(t1.f2))) > 50) or (rollup_group_item(t1.f1,0) is null))  (cost=*** rows=***)
            -> Group aggregate with rollup: sum(t1.f2)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE j+sum > 50 OR
j IS NULL;
j	sum
NULL	2
3	66
4	88
NULL	222
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP
HAVING AVG(f2) > 1) AS dt WHERE j+sum > 50 OR
j IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((rollup_sum_switcher(avg(t1.f2)) > 1) and (((rollup_group_item(t1.f1,0) + rollup_sum_switcher(sum(t1.f2))) > 50) or (rollup_group_item(t1.f1,0) is null)))  (cost=*** rows=***)
            -> Group aggregate with rollup: avg(t1.f2), sum(t1.f2)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP
HAVING AVG(f2) > 1) AS dt WHERE j+sum > 50 OR
j IS NULL;
j	sum
3	66
4	88
NULL	222
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2) as dt
WHERE f1 > 3;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Sort: t1.f2  (cost=*** rows=***)
            -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2) as dt
WHERE f1 > 3;
f1
4
4
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2 LIMIT 4) as dt
WHERE f1 > 0 ;
EXPLAIN
-> Filter: (dt.f1 > 0)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Limit: 4 row(s)  (cost=*** rows=***)
                -> Sort: t1.f2, limit input to 4 row(s) per chunk  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2

SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2 LIMIT 4) as dt
WHERE f1 > 0 ;
f1
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 LIMIT 4) as dt WHERE f1 > 0;
EXPLAIN
-> Filter: (dt.f1 > 0)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Limit: 4 row(s)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2 FROM t1 LIMIT 4) as dt WHERE f1 > 0;
f1
set sql_mode="";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
EXPLAIN
-> Filter: (dt.f1 > 2)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Window aggregate with buffering: sum(t1.f2) OVER () 
                -> Table scan on <temporary>  (cost=*** rows=***)
                    -> Temporary table with deduplication  (cost=*** rows=***)
                        -> Covering index range scan on t1 using index_for_group_by(f1_2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
f1	SUM(f2) OVER()
3	111
4	111
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt WHERE f1 > 2;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1 ) 
            -> Sort: t1.f1
                -> Table scan on <temporary>  (cost=*** rows=***)
                    -> Temporary table with deduplication  (cost=*** rows=***)
                        -> Filter: (t1.f1 > 2)  (cost=*** rows=***)
                            -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt WHERE f1 > 2;
f1	SUM(f2) OVER(PARTITION BY f1)
3	33
4	44
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f2)
FROM t1 GROUP BY f1) as dt WHERE f2 > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f2 ) 
            -> Filter: (t1.f2 > 30)
                -> Sort: t1.f2
                    -> Table scan on <temporary>  (cost=*** rows=***)
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Table scan on t1  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f2)
FROM t1 GROUP BY f1) as dt WHERE f2 > 30;
f1	f2	SUM(f3) OVER(PARTITION BY f2)
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Filter: ((dt.f2 > 30) and ((dt.f1 + dt.f2) > 40))  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>  (cost=*** rows=***)
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1)
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1,t1.f2 ) 
            -> Filter: ((t1.f2 > 30) and ((t1.f1 + t1.f2) > 40))
                -> Sort: t1.f1, t1.f2
                    -> Table scan on <temporary>  (cost=*** rows=***)
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1,f2)
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2),
AVG(f3) OVER (PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Filter: ((dt.f2 > 30) and ((dt.f1 + dt.f2) > 40))  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>  (cost=*** rows=***)
                        -> Temporary table  (cost=*** rows=***)
                            -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1,t1.f2 ) 
                                -> Sort: t1.f1, t1.f2
                                    -> Table scan on <temporary>  (cost=*** rows=***)
                                        -> Temporary table with deduplication  (cost=*** rows=***)
                                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2),
AVG(f3) OVER (PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1,f2)	AVG(f3) OVER (PARTITION BY f1)
4	44	444	444.0000
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) as SUM, AVG(f3) OVER (PARTITION BY SUM(f2))
FROM t1 GROUP BY f1) as dt
WHERE SUM > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY sum(t1.f2) ) 
            -> Filter: (sum(t1.f2) > 40)
                -> Sort: SUM
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Table scan on t1  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) as SUM, AVG(f3) OVER (PARTITION BY SUM(f2))
FROM t1 GROUP BY f1) as dt
WHERE SUM > 40;
f1	SUM	AVG(f3) OVER (PARTITION BY SUM(f2))
2	44	222.0000
3	66	333.0000
4	88	444.0000
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) OVER (PARTITION by f1,f2),
AVG(f3) OVER (PARTITION BY f2,f1),
FIRST_VALUE(f3) OVER (PARTITION by f1)
FROM t1) as dt
WHERE f1 > 2 ;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Window aggregate with buffering: first_value(t1.f3) OVER (PARTITION BY t1.f1 ) 
            -> Sort: t1.f1
                -> Table scan on <temporary>  (cost=*** rows=***)
                    -> Temporary table  (cost=*** rows=***)
                        -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY t1.f2,t1.f1 ) 
                            -> Sort: t1.f2, t1.f1
                                -> Table scan on <temporary>  (cost=*** rows=***)
                                    -> Temporary table  (cost=*** rows=***)
                                        -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1,t1.f2 ) 
                                            -> Sort: t1.f1, t1.f2  (cost=*** rows=***)
                                                -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) OVER (PARTITION by f1,f2),
AVG(f3) OVER (PARTITION BY f2,f1),
FIRST_VALUE(f3) OVER (PARTITION by f1)
FROM t1) as dt
WHERE f1 > 2 ;
f1	SUM(f2) OVER (PARTITION by f1,f2)	AVG(f3) OVER (PARTITION BY f2,f1)	FIRST_VALUE(f3) OVER (PARTITION by f1)
3	66	333.0000	333
3	66	333.0000	333
4	88	444.0000	444
4	88	444.0000	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f1) OVER (PARTITION by f2),
AVG(f2) OVER (PARTITION BY f1)
FROM t1) as dt
WHERE f1 > 2 ;
EXPLAIN
-> Filter: (dt.f1 > 2)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Window aggregate with buffering: avg(t1.f2) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>  (cost=*** rows=***)
                        -> Temporary table  (cost=*** rows=***)
                            -> Window aggregate with buffering: sum(t1.f1) OVER (PARTITION BY t1.f2 ) 
                                -> Sort: t1.f2  (cost=*** rows=***)
                                    -> Index scan on t1 using f1_2

SELECT *
FROM (SELECT f1, SUM(f1) OVER (PARTITION by f2),
AVG(f2) OVER (PARTITION BY f1)
FROM t1) as dt
WHERE f1 > 2 ;
f1	SUM(f1) OVER (PARTITION by f2)	AVG(f2) OVER (PARTITION BY f1)
3	6	33.0000
3	6	33.0000
4	8	44.0000
4	8	44.0000
set sql_mode=default;
SET @p1 = 3;
PREPARE p FROM "SELECT f1
FROM (SELECT f1 FROM t1) as dt WHERE f1 > ?";
EXECUTE p USING @p1;
f1
4
4
PREPARE p FROM "EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1 FROM t1) as dt WHERE f1 > ?";
EXECUTE p USING @p1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1  (cost=*** rows=***)

DROP PREPARE p;
SET @p1 = 10;
PREPARE p FROM "SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+?) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ";
EXECUTE p USING @p1;
l	m
27	236
39	347
51	458
27	236
39	347
51	458
PREPARE p FROM "EXPLAIN FORMAT=tree SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+?) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ";
EXECUTE p USING @p1;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((dt1.i + 3) + (dt1.j + 4)) > 10)  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: (((t1.f1 + t1.f2) + 3) > 20)  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM (SELECT RAND() as a FROM t1) as dt
WHERE a > 0.5;
EXPLAIN
-> Filter: (dt.a > 0.5)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Index scan on t1 using f1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3*RAND() AND f1 < 10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > (3 * rand()))  (cost=*** rows=***)
            -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
                -> Filter: (t1.f1 < 10)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM
(SELECT f1, SUM(f2) OVER(PARTITION BY f1) FROM t1) as dt
WHERE f1 > 3*RAND() AND f1 < 10;
EXPLAIN
-> Filter: (dt.f1 > (3 * rand()))  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1  (cost=*** rows=***)
                    -> Filter: (t1.f1 < 10)  (cost=*** rows=***)
                        -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM
(SELECT f1 FROM t1) as dt
WHERE f1 > 3*RAND() AND f1<10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 > (3 * rand())) and (t1.f1 < 10))  (cost=*** rows=***)
            -> Covering index range scan on t1 using f1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1 FROM t1 UNION SELECT f2 FROM t1) as dt
WHERE f1 > 2;
EXPLAIN
-> Filter: (dt.f1 > 2)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Union materialize with deduplication  (cost=*** rows=***)
            -> Index scan on t1 using f1  (cost=*** rows=***)
            -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1
FROM (SELECT f1 FROM t1 UNION SELECT f2 FROM t1) as dt
WHERE f1 > 2;
f1
3
4
11
22
33
44
EXPLAIN FORMAT=tree SELECT f1 FROM
(SELECT (SELECT 1 FROM t1 LIMIT 1) as f1 FROM t1) as dt WHERE f1 = 1;
EXPLAIN
-> Covering index lookup on dt using <auto_key0> (f1=1)
    -> Materialize  (cost=*** rows=***)
        -> Index scan on t1 using f1  (cost=*** rows=***)
        -> Select #3 (subquery in projection; run only once)
            -> Limit: 1 row(s)  (cost=*** rows=***)
                -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT f1 FROM
(SELECT (SELECT 1 FROM t1 LIMIT 1) as f1 FROM t1) as dt WHERE f1 = 1;
f1
1
1
1
1
1
1
1
1
1
1
1
1
CREATE FUNCTION p() RETURNS INTEGER
BEGIN
DECLARE retn INTEGER;
SELECT count(f1) FROM t1 INTO retn;
RETURN retn;
END|
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (p() = 1)  (cost=*** rows=***)
            -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
f1	SUM(f2)
DROP FUNCTION p;
CREATE FUNCTION p() RETURNS INTEGER DETERMINISTIC
BEGIN
DECLARE retn INTEGER;
SELECT count(f1) FROM t1 INTO retn;
RETURN retn;
END|
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
            -> Filter: <cache>((p() = 1))  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
f1	SUM(f2)
DROP FUNCTION p;
CREATE PROCEDURE p()
BEGIN
DECLARE val INTEGER;
SET val = 2;
EXPLAIN FORMAT=tree SELECT AVG(f1) FROM (SELECT * FROM t1) as dt
WHERE f2 > val;
SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val;
END|
CALL p();
EXPLAIN
-> Aggregate: avg(dt.f1)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f2 > <cache>(val@0))  (cost=*** rows=***)
                -> Table scan on t1  (cost=*** rows=***)

AVG(f1)
2.5000
DROP PROCEDURE p;
EXPLAIN FORMAT=tree SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn2)) as dt WHERE f2 > 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on qn2  (cost=*** rows=***)
            -> Materialize CTE qn2  (cost=*** rows=***)
                -> Table scan on qn  (cost=*** rows=***)
                    -> Materialize CTE qn  (cost=*** rows=***)
                        -> Filter: ((3 * (10 * t1.f1)) > 1)  (cost=*** rows=***)
                            -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn2)) as dt WHERE f2 > 1;
f2
120
120
30
30
60
60
90
90
EXPLAIN FORMAT=tree SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn,qn2)) as dt WHERE f1 < 10 and f2 > 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on qn2  (cost=*** rows=***)
                -> Materialize CTE qn2  (cost=*** rows=***)
                    -> Filter: ((3 * qn.f1) > 1)  (cost=*** rows=***)
                        -> Table scan on qn  (cost=*** rows=***)
                            -> Materialize CTE qn if needed (query plan printed elsewhere)  (cost=*** rows=***)
            -> Hash
                -> Filter: (qn.f1 < 10)  (cost=*** rows=***)
                    -> Table scan on qn  (cost=*** rows=***)
                        -> Materialize CTE qn if needed  (cost=*** rows=***)
                            -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn,qn2)) as dt WHERE f1 < 10 and f2 > 1;
f1	f2
0	120
0	120
0	120
0	120
0	30
0	30
0	30
0	30
0	60
0	60
0	60
0	60
0	90
0	90
0	90
0	90
EXPLAIN FORMAT=tree SELECT * FROM t1 JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 31 and t1.f2  > 40;
EXPLAIN
-> Nested loop inner join  (cost=*** rows=***)
    -> Filter: ((t1.f2 > 40) and (t1.f2 is not null))  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
    -> Index lookup on dt using <auto_key0> (f2=t1.f2)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f1 > 31)  (cost=*** rows=***)
                -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 31 and t1.f2  > 40;
f2	f1	f3	f1
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 is null;
EXPLAIN
-> Filter: (dt.f1 is null)  (cost=*** rows=***)
    -> Left hash join (dt.f2 = t1.f2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 is null;
f2	f1	f3	f1
1	NULL	2	NULL
1	NULL	2	NULL
1	NULL	3	NULL
1	NULL	3	NULL
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 3;
EXPLAIN
-> Inner hash join (t1.f2 = dt.f2)  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Hash
        -> Table scan on dt  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 3;
f2	f1	f3	f1
44	4	444	4
44	4	444	4
44	4	444	4
44	4	444	4
EXPLAIN FORMAT=tree SELECT * FROM t1 INNER JOIN (SELECT f1, f2 FROM t1) as dt ON dt.f1 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Hash
        -> Table scan on dt  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 INNER JOIN (SELECT f1, f2 FROM t1) as dt ON dt.f1 > 3;
f1	f2	f3	f1	f2
0	0	0	4	44
0	0	0	4	44
0	0	0	4	44
0	0	0	4	44
1	11	111	4	44
1	11	111	4	44
1	11	111	4	44
1	11	111	4	44
2	22	222	4	44
2	22	222	4	44
2	22	222	4	44
2	22	222	4	44
3	33	333	4	44
3	33	333	4	44
3	33	333	4	44
3	33	333	4	44
4	44	444	4	44
4	44	444	4	44
4	44	444	4	44
4	44	444	4	44
NULL	1	2	4	44
NULL	1	2	4	44
NULL	1	3	4	44
NULL	1	3	4	44
EXPLAIN FORMAT = tree SELECT * FROM t1 INNER JOIN(SELECT t2.f1, t2.f2 FROM t1
LEFT JOIN t1 AS t2 ON TRUE) AS dt ON dt.f1 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t2.f1 > 3)  (cost=*** rows=***)
                -> Left hash join (no condition)  (cost=*** rows=***)
                    -> Index scan on t1 using f1  (cost=*** rows=***)
                    -> Hash
                        -> Index scan on t2 using f1_2  (cost=*** rows=***)
    -> Hash
        -> Table scan on t1  (cost=*** rows=***)

set optimizer_switch="derived_merge=on";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM t1 GROUP BY f1) as dt1
WHERE f1 > 10) dt2 WHERE sum > 10;
EXPLAIN
-> Table scan on dt1  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (sum(t1.f2) > 10)  (cost=*** rows=***)
            -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
                -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM t1 GROUP BY f1) as dt1
WHERE f1 > 10) dt2 WHERE sum > 10;
f1	sum
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM (SELECT f1, f2 FROM t1 WHERE f1 > 10) as dt1
GROUP BY f1) dt2 WHERE sum > 10;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (sum(t1.f2) > 10)  (cost=*** rows=***)
            -> Group aggregate: sum(t1.f2)  (cost=*** rows=***)
                -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
                    -> Covering index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM (SELECT f1, f2 FROM t1 WHERE f1 > 10) as dt1
GROUP BY f1) dt2 WHERE sum > 10;
f1	sum
SELECT * FROM
(SELECT f1 FROM (SELECT f1 FROM t1) AS dt1 GROUP BY f1) AS dt2
WHERE f1 > 3;
f1
4
SELECT * FROM
(SELECT dt1.f1 FROM (SELECT f1 FROM t1) AS dt1, t1 AS t0
GROUP BY dt1.f1) AS dt2
WHERE dt2.f1 > 3;
f1
4
EXPLAIN SELECT /*+ no_merge(dt,dt1) */ * FROM
((SELECT f1, f2 FROM t1) as dt, (SELECT f1, f2 FROM t1) as dt1) WHERE FALSE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	NULL	Impossible WHERE
3	DERIVED	t1	NULL	index	NULL	f1_2	10	NULL	#	100.00	Using index
2	DERIVED	t1	NULL	index	NULL	f1_2	10	NULL	#	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select /*+ NO_MERGE(`dt`@`select#1`) NO_MERGE(`dt1`@`select#1`) */ `dt`.`f1` AS `f1`,`dt`.`f2` AS `f2`,`dt1`.`f1` AS `f1`,`dt1`.`f2` AS `f2` from (/* select#2 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1`) `dt` join (/* select#3 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1`) `dt1` where false
SELECT /*+ no_merge(dt,dt1) */ * FROM
((SELECT f1, f2 FROM t1) as dt, (SELECT f1, f2 FROM t1) as dt1) WHERE FALSE;
f1	f2	f1	f2
set optimizer_switch="derived_merge=off";
EXPLAIN FORMAT=tree SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Filter: (dt2.f1 > 3)  (cost=*** rows=***)
    -> Table scan on dt2  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN() */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Filter: (dt2.f1 > 3)  (cost=*** rows=***)
    -> Table scan on dt2  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN() */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
set optimizer_switch="derived_condition_pushdown=off";
EXPLAIN FORMAT=tree SELECT /*+ DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt1) */ * FROM
(SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (dt1.f1 > 3)  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt1) */ * FROM
(SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
set optimizer_switch=default;
# Bug#31491972: WL8084: SERVER CRASH FROM JOIN::UPDATE_SARGABLE_FROM_CONST()
SELECT f1 FROM (SELECT DISTINCT * FROM t1 WHERE f2 = 4) AS alias1
WHERE ( alias1 . f1 = 24 AND alias1 . f3 = 101 );
f1
SELECT f1 FROM (SELECT DISTINCT * FROM t1 WHERE f2 = 4) AS alias1
WHERE ( alias1 . f1 BETWEEN 24 AND 30 AND alias1 . f3 BETWEEN 101 and 103);
f1
DROP TABLE t0, t1;
#
# Bug#31603289:CRASH IN TABLE_LIST::GET_CLONE_FOR_DERIVED_EXPR,
#              ASSERTION `FALSE' IN TABLE_LIST::GET_DERIVED_EXPR
#
CREATE TABLE t(f0 INTEGER PRIMARY KEY, f1 INTEGER,f2 INTEGER);
SELECT NULL IN(SELECT (f1 between 0 and 1)
FROM (SELECT f1 FROM t WHERE  (@b:=NULL) - f2)as dt
);
NULL IN(SELECT (f1 between 0 and 1)
)
0
FROM (SELECT f1 FROM t WHERE  (@b:=NULL) - f2)as dt
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
Warnings:
DROP TABLE t;
#
# Bug#32127562:ERROR 3566 (HY000): ACCESS TO NATIVE FUNCTION IS
#              REJECTED
#
set optimizer_switch="derived_merge=off";
SELECT 1 FROM information_schema.tables WHERE 123 IN (CONCAT_WS(TABLE_ROWS, ''));
1
set optimizer_switch="derived_merge=on";
# BUG#32150145: 8.0.22+ RELEASE BUILD QUERY FAILS SILENTLY,
#                DEBUG ASSERTION `THD->IS_ERROR()'
#
CREATE TABLE t1(g INTEGER);
SELECT w.g FROM t1 INNER JOIN (
SELECT g, ROW_NUMBER() OVER (PARTITION BY g) AS r FROM t1
) w ON w.g=t1.g AND w.r=1 WHERE w.g IS NULL;
g
DROP TABLE t1;
#
# BUG#32863713: CTE CRASH IN QUERY_BLOCK::MASTER_QUERY_EXPRESSION
#
CREATE TABLE t(f1 INTEGER);
EXPLAIN SELECT a1, a2
FROM (SELECT MAX(2) AS a1 FROM t) as dt1,
(SELECT @a AS a2 FROM t) as dt2
WHERE dt1.a1 <= dt2.a2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
2	DERIVED	t	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select NULL AS `a1`,(@`a`) AS `a2` from (/* select#2 */ select max(2) AS `a1` from `test`.`t` having (max(2) <= <cache>((@`a`)))) `dt1` join `test`.`t`
SELECT a1, a2
FROM (SELECT MAX(f1) AS a1 FROM t) as dt1,
(SELECT @a AS a2 FROM t) as dt2
WHERE dt1.a1 <= dt2.a2;
a1	a2
DROP TABLE t;
#
# Bug#32905044: CRASH AT CONDITION_PUSHDOWN::REPLACE_COLUMNS_IN_COND
#	       DURIN RQG CONCURRENCY RUNS
CREATE TABLE t(f1 INTEGER);
CREATE ALGORITHM=temptable VIEW v AS SELECT f1 FROM t;
SELECT f1 FROM (SELECT f1 FROM v) AS dt1 NATURAL JOIN v dt2 WHERE f1 > 5;
f1
DROP TABLE t;
DROP VIEW v;
#
# Bug#32959186: DERIVED CONDITION PUSHDOWN IS NOT AVAILABLE FOR
#               INSERT ... SELECT QUERIES
CREATE TABLE t1(f1 INTEGER, KEY(f1));
CREATE TABLE t2(f1 INTEGER);
INSERT INTO t1 VALUES (1),(2),(3),(4),(5);
CREATE ALGORITHM=temptable VIEW v AS SELECT f1 FROM t1;
EXPLAIN format=tree INSERT INTO t2 SELECT * FROM v WHERE f1=2;
EXPLAIN
-> Insert into t2
    -> Table scan on v
        -> Materialize
            -> Covering index lookup on t1 using f1 (f1=2)

INSERT INTO t2 SELECT * FROM v WHERE f1=2;
EXPLAIN format=tree UPDATE t2 SET f1=3 WHERE f1 IN (SELECT f1 FROM v WHERE f1=2);
EXPLAIN
-> Update t2 (immediate)
    -> Nested loop semijoin
        -> Filter: (t2.f1 is not null)
            -> Table scan on t2
        -> Covering index lookup on v using <auto_key0> (f1=t2.f1)
            -> Materialize
                -> Covering index lookup on t1 using f1 (f1=2)

UPDATE t2 SET f1=3 WHERE f1 IN (SELECT f1 FROM v WHERE f1=2);
EXPLAIN format=tree DELETE FROM t2 WHERE f1 IN (SELECT f1 FROM v WHERE f1=3);
EXPLAIN
-> Delete from t2 (immediate)
    -> Nested loop semijoin
        -> Filter: (t2.f1 is not null)
            -> Table scan on t2
        -> Covering index lookup on v using <auto_key0> (f1=t2.f1)
            -> Materialize
                -> Covering index lookup on t1 using f1 (f1=3)

DELETE FROM t2 WHERE f1 IN (SELECT f1 FROM v WHERE f1=3);
DROP TABLE t1;
DROP TABLE t2;
DROp VIEW v;
