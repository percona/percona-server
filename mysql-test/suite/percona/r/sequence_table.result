###
### Checking invalid SEQUENCE_TABLE() arguments
###
# no arguments
SELECT * FROM SEQUENCE_TABLE() AS tt;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ') AS tt' at line 1
# two arguments
SELECT * FROM SEQUENCE_TABLE(1, 2) AS tt;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ', 2) AS tt' at line 1
###
### Checking SEQUENCE_TABLE() without table alias
###
SELECT * FROM SEQUENCE_TABLE(4);
ERROR 42000: Every table function must have an alias
###
### Simple usage scenarios
###
### SELECT value FROM SEQUENCE_TABLE(0) AS tt ###
SELECT value FROM SEQUENCE_TABLE(0) AS tt;
value
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(0) AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(0) AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(0) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(0) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(0) AS tt;
EXPLAIN
-> Materialize table function


### SELECT value FROM SEQUENCE_TABLE(1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(1) AS tt;
value
0
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(1) AS tt] should return 1 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(1) AS tt] should return "0"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(1) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(1) AS tt;
EXPLAIN
-> Materialize table function


### SELECT value FROM SEQUENCE_TABLE(4) AS tt ###
SELECT value FROM SEQUENCE_TABLE(4) AS tt;
value
0
1
2
3
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt] should return 4 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(4) AS tt] should return "0,1,2,3"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(4) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(4) AS tt;
EXPLAIN
-> Materialize table function


###
### Checking SEQUENCE_TABLE() max records limit
###
SET @saved_tf_sequence_table_max_upper_bound = @@global.tf_sequence_table_max_upper_bound;
SELECT * FROM SEQUENCE_TABLE(@saved_tf_sequence_table_max_upper_bound) AS tt;
SELECT * FROM SEQUENCE_TABLE(@saved_tf_sequence_table_max_upper_bound + 1) AS tt;
ERROR HY000: The number of records generated by SEQUENCE_TABLE() cannot exceed 1048576 (1048577 requested). Try increasing @@tf_sequence_table_max_upper_bound to a larger value.
SET GLOBAL tf_sequence_table_max_upper_bound = @saved_tf_sequence_table_max_upper_bound + 1;
SELECT * FROM SEQUENCE_TABLE(@saved_tf_sequence_table_max_upper_bound + 1) AS tt;
SELECT * FROM SEQUENCE_TABLE(@saved_tf_sequence_table_max_upper_bound + 2) AS tt;
ERROR HY000: The number of records generated by SEQUENCE_TABLE() cannot exceed 1048577 (1048578 requested). Try increasing @@tf_sequence_table_max_upper_bound to a larger value.
SET GLOBAL tf_sequence_table_max_upper_bound = @saved_tf_sequence_table_max_upper_bound;
###
### Checking SEQUENCE_TABLE() upper bound value conversions
###
# Negative numbers
### SELECT value FROM SEQUENCE_TABLE(-1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(-1) AS tt;
value
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(-1) AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(-1) AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(-1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(-(1)) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(-1) AS tt;
EXPLAIN
-> Materialize table function


# NULL value
### SELECT value FROM SEQUENCE_TABLE(NULL) AS tt ###
SELECT value FROM SEQUENCE_TABLE(NULL) AS tt;
value
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(NULL) AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(NULL) AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(NULL) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(NULL) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(NULL) AS tt;
EXPLAIN
-> Materialize table function


# Floating point numbers
### SELECT value FROM SEQUENCE_TABLE(2.5) AS tt ###
SELECT value FROM SEQUENCE_TABLE(2.5) AS tt;
value
0
1
2
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(2.5) AS tt] should return 3 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(2.5) AS tt] should return "0,1,2"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(2.5) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(2.5) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(2.5) AS tt;
EXPLAIN
-> Materialize table function


### SELECT value FROM SEQUENCE_TABLE(0.15E1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(0.15E1) AS tt;
value
0
1
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(0.15E1) AS tt] should return 2 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(0.15E1) AS tt] should return "0,1"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(0.15E1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(0.15E1) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(0.15E1) AS tt;
EXPLAIN
-> Materialize table function


### SELECT value FROM SEQUENCE_TABLE(0.15E-1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(0.15E-1) AS tt;
value
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(0.15E-1) AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(0.15E-1) AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(0.15E-1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(0.15E-1) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(0.15E-1) AS tt;
EXPLAIN
-> Materialize table function


# String values
### SELECT value FROM SEQUENCE_TABLE("") AS tt ###
SELECT value FROM SEQUENCE_TABLE("") AS tt;
value
Warnings:
Warning	1292	Truncated incorrect INTEGER value: ''
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE("") AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE("") AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE("") AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Warning	1292	Truncated incorrect INTEGER value: ''
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table('') `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE("") AS tt;
EXPLAIN
-> Materialize table function

Warnings:
Warning	1292	Truncated incorrect INTEGER value: ''

### SELECT value FROM SEQUENCE_TABLE(" ") AS tt ###
SELECT value FROM SEQUENCE_TABLE(" ") AS tt;
value
Warnings:
Warning	1292	Truncated incorrect INTEGER value: ' '
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(" ") AS tt] should return 0 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(" ") AS tt] should return ""]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(" ") AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Warning	1292	Truncated incorrect INTEGER value: ' '
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(' ') `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(" ") AS tt;
EXPLAIN
-> Materialize table function

Warnings:
Warning	1292	Truncated incorrect INTEGER value: ' '

### SELECT value FROM SEQUENCE_TABLE("2") AS tt ###
SELECT value FROM SEQUENCE_TABLE("2") AS tt;
value
0
1
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE("2") AS tt] should return 2 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE("2") AS tt] should return "0,1"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE("2") AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table('2') `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE("2") AS tt;
EXPLAIN
-> Materialize table function


###
### Checking SEQUENCE_TABLE() upper bound expressions
###
# Session variables
SET @a = 4;
### SELECT value FROM SEQUENCE_TABLE(@a) AS tt ###
SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
value
0
1
2
3
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(@a) AS tt] should return 4 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(@a) AS tt] should return "0,1,2,3"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table((@`a`)) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
EXPLAIN
-> Materialize table function


SET @a = 3;
### SELECT value FROM SEQUENCE_TABLE(@a) AS tt ###
SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
value
0
1
2
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(@a) AS tt] should return 3 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(@a) AS tt] should return "0,1,2"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table((@`a`)) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(@a) AS tt;
EXPLAIN
-> Materialize table function


# Simple arithmetic expressions
SET @a = 2;
### SELECT value FROM SEQUENCE_TABLE(@a * @a - 1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(@a * @a - 1) AS tt;
value
0
1
2
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(@a * @a - 1) AS tt] should return 3 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(@a * @a - 1) AS tt] should return "0,1,2"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(@a * @a - 1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table((((@`a`) * (@`a`)) - 1)) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(@a * @a - 1) AS tt;
EXPLAIN
-> Materialize table function


SET @a = 1;
### SELECT value FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt ###
SELECT value FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt;
value
0
1
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt] should return 2 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt] should return "0,1"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table((exp((@`a`)) - 1)) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(EXP(@a) - 1) AS tt;
EXPLAIN
-> Materialize table function


###
### Checking SEQUENCE_TABLE() with WHERE clause
###
# Point selection
### SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1 ###
SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1;
value
1
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1] should return 1 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1] should return "1"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ref	<auto_key0>	<auto_key0>	8	const	1	100.00	Table function: sequence_table; Using temporary; Using index
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(4) `tt` where (`tt`.`value` = 1)
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value = 1;
EXPLAIN
-> Materialize table function


# Range selection
### SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1 ###
SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1;
value
2
3
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1] should return 2 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1] should return "2,3"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Table function: sequence_table; Using temporary; Using where
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(4) `tt` where (`tt`.`value` > 1)
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value > 1;
EXPLAIN
-> Filter: (tt.`value` > 1)
    -> Materialize table function


# Every second record
### SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0 ###
SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0;
value
0
2
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0] should return 2 records]
include/assert.inc [[SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0] should return "0,2"]
EXPLAIN SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary; Using where
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(4) `tt` where ((`tt`.`value` % 2) = 0)
EXPLAIN FORMAT=TREE SELECT value FROM SEQUENCE_TABLE(4) AS tt WHERE value %2 = 0;
EXPLAIN
-> Filter: ((tt.`value` % 2) = 0)
    -> Materialize table function


###
### Selecting custom value expressions from SEQUENCE_TABLE()
###
# Shifted values
### SELECT value + 1 FROM SEQUENCE_TABLE(4) AS tt ###
SELECT value + 1 FROM SEQUENCE_TABLE(4) AS tt;
value + 1
1
2
3
4
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt] should return 4 records]
include/assert.inc [[SELECT value + 1 FROM SEQUENCE_TABLE(4) AS tt] should return "1,2,3,4"]
EXPLAIN SELECT value + 1 FROM SEQUENCE_TABLE(4) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select (`tt`.`value` + 1) AS `value + 1` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT value + 1 FROM SEQUENCE_TABLE(4) AS tt;
EXPLAIN
-> Materialize table function


# Odd numbers
### SELECT value * 2 + 1 FROM SEQUENCE_TABLE(4) AS tt ###
SELECT value * 2 + 1 FROM SEQUENCE_TABLE(4) AS tt;
value * 2 + 1
1
3
5
7
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt] should return 4 records]
include/assert.inc [[SELECT value * 2 + 1 FROM SEQUENCE_TABLE(4) AS tt] should return "1,3,5,7"]
EXPLAIN SELECT value * 2 + 1 FROM SEQUENCE_TABLE(4) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select ((`tt`.`value` * 2) + 1) AS `value * 2 + 1` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT value * 2 + 1 FROM SEQUENCE_TABLE(4) AS tt;
EXPLAIN
-> Materialize table function


# Reverse order
### SELECT 7 - value FROM SEQUENCE_TABLE(4) AS tt ###
SELECT 7 - value FROM SEQUENCE_TABLE(4) AS tt;
7 - value
7
6
5
4
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt] should return 4 records]
include/assert.inc [[SELECT 7 - value FROM SEQUENCE_TABLE(4) AS tt] should return "7,6,5,4"]
EXPLAIN SELECT 7 - value FROM SEQUENCE_TABLE(4) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select (7 - `tt`.`value`) AS `7 - value` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT 7 - value FROM SEQUENCE_TABLE(4) AS tt;
EXPLAIN
-> Materialize table function


# Mapping with ELT()
### SELECT ELT(value + 1, "a", "b", "c", "d") FROM SEQUENCE_TABLE(4) AS tt ###
SELECT ELT(value + 1, "a", "b", "c", "d") FROM SEQUENCE_TABLE(4) AS tt;
ELT(value + 1, "a", "b", "c", "d")
a
b
c
d
include/assert.inc [[SELECT COUNT(*) FROM SEQUENCE_TABLE(4) AS tt] should return 4 records]
include/assert.inc [[SELECT ELT(value + 1, "a", "b", "c", "d") FROM SEQUENCE_TABLE(4) AS tt] should return "a,b,c,d"]
EXPLAIN SELECT ELT(value + 1, "a", "b", "c", "d") FROM SEQUENCE_TABLE(4) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select elt((`tt`.`value` + 1),'a','b','c','d') AS `ELT(value + 1, "a", "b", "c", "d")` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT ELT(value + 1, "a", "b", "c", "d") FROM SEQUENCE_TABLE(4) AS tt;
EXPLAIN
-> Materialize table function


###
### Checking VIEWs based on SEQUENCE_TABLE()
###
CREATE VIEW v1 AS SELECT * FROM SEQUENCE_TABLE(4) AS tt;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `tt`.`value` AS `value` from sequence_table(4) `tt`	utf8mb4	utf8mb4_0900_ai_ci
### SELECT value FROM v1 ###
SELECT value FROM v1;
value
0
1
2
3
include/assert.inc [[SELECT COUNT(*) FROM v1] should return 4 records]
include/assert.inc [[SELECT value FROM v1] should return "0,1,2,3"]
EXPLAIN SELECT value FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`value` AS `value` from sequence_table(4) `tt`
EXPLAIN FORMAT=TREE SELECT value FROM v1;
EXPLAIN
-> Materialize table function


DROP VIEW v1;
###
### Checking stored procedures / functions
###
# Stored procedure
CREATE PROCEDURE p1(upper_bound BIGINT UNSIGNED) SELECT * FROM SEQUENCE_TABLE(upper_bound) AS tt;
CALL p1(4);
value
0
1
2
3
DROP PROCEDURE p1;
# Stored function
CREATE FUNCTION f1(upper_bound BIGINT UNSIGNED) RETURNS BIGINT UNSIGNED
BEGIN
DECLARE res BIGINT UNSIGNED;
SELECT SUM(value) INTO res FROM SEQUENCE_TABLE(upper_bound) AS tt;
RETURN res;
END|
include/assert.inc [SUM(0, ..., 3) should be 6]
SELECT f1(4);
f1(4)
6
DROP FUNCTION f1;
###
### Checking prepared statements
###
PREPARE stmt1 FROM 'SELECT * FROM SEQUENCE_TABLE(?) AS tt';
SET @a = 4;
EXECUTE stmt1 USING @a;
value
0
1
2
3
DEALLOCATE PREPARE stmt1;
###
### Checking SHOW CREATE TABLE
###
CREATE TABLE t1 AS SELECT value AS a FROM SEQUENCE_TABLE(3) AS tt;
SHOW CREATE TABLE t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` bigint unsigned NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
###
### Checking table joins
###
# Constant upper_bound
### SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(3) AS tt ###
SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(3) AS tt;
t1.a * 10 + value
2
1
0
12
11
10
22
21
20
include/assert.inc [[SELECT COUNT(*) FROM t1, SEQUENCE_TABLE(3) AS tt] should return 9 records]
include/assert.inc [[SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(3) AS tt] should return "0,1,2,10,11,12,20,21,22"]
EXPLAIN SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(3) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`a` * 10) + `tt`.`value`) AS `t1.a * 10 + value` from `test`.`t1` join sequence_table(3) `tt`
EXPLAIN FORMAT=TREE SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(3) AS tt;
EXPLAIN
-> Inner hash join (no condition)
    -> Table scan on t1  (cost=0.275 rows=3)
    -> Hash
        -> Materialize table function


# Join with UNION-based row set
### SELECT tt1.a * 10 + value FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2 ###
SELECT tt1.a * 10 + value FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2;
tt1.a * 10 + value
2
1
0
12
11
10
22
21
20
include/assert.inc [[SELECT COUNT(*) FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return 9 records]
include/assert.inc [[SELECT tt1.a * 10 + value FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return "0,1,2,10,11,12,20,21,22"]
EXPLAIN SELECT tt1.a * 10 + value FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	tt2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
5	UNION RESULT	<union2,3,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select ((`tt1`.`a` * 10) + `tt2`.`value`) AS `tt1.a * 10 + value` from (/* select#2 */ select 0 AS `a` union /* select#3 */ select 1 AS `1` union /* select#4 */ select 2 AS `2`) `tt1` join sequence_table(3) `tt2`
EXPLAIN FORMAT=TREE SELECT tt1.a * 10 + value FROM (SELECT 0 AS a UNION SELECT 1 UNION SELECT 2) AS tt1, SEQUENCE_TABLE(3) AS tt2;
EXPLAIN
-> Inner hash join (no condition)
    -> Table scan on tt1  (cost=1.15..2.84 rows=3)
        -> Union materialize with deduplication  (cost=0.3..0.3 rows=3)
            -> Rows fetched before execution  (cost=0..0 rows=1)
            -> Rows fetched before execution  (cost=0..0 rows=1)
            -> Rows fetched before execution  (cost=0..0 rows=1)
    -> Hash
        -> Materialize table function


# Join with VALUES ROW-based row set
### SELECT tt1.column_0 * 10 + value FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2 ###
SELECT tt1.column_0 * 10 + value FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2;
tt1.column_0 * 10 + value
2
1
0
12
11
10
22
21
20
include/assert.inc [[SELECT COUNT(*) FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return 9 records]
include/assert.inc [[SELECT tt1.column_0 * 10 + value FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return "0,1,2,10,11,12,20,21,22"]
EXPLAIN SELECT tt1.column_0 * 10 + value FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	tt2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
Warnings:
Note	1003	/* select#1 */ select ((`tt1`.`column_0` * 10) + `tt2`.`value`) AS `tt1.column_0 * 10 + value` from (values row(0),row(1),row(2)) `tt1` join sequence_table(3) `tt2`
EXPLAIN FORMAT=TREE SELECT tt1.column_0 * 10 + value FROM (VALUES ROW(0), ROW(1), ROW(2)) AS tt1, SEQUENCE_TABLE(3) AS tt2;
EXPLAIN
-> Inner hash join (no condition)
    -> Table scan on tt1  (cost=1.15..2.84 rows=3)
        -> Materialize  (cost=0.3..0.3 rows=3)
            -> Rows fetched before execution  (cost=0..0 rows=3)
    -> Hash
        -> Materialize table function


# Join with derived SELECT
### SELECT tt1.a * 10 + value FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2 ###
SELECT tt1.a * 10 + value FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
tt1.a * 10 + value
2
1
0
12
11
10
22
21
20
include/assert.inc [[SELECT COUNT(*) FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return 9 records]
include/assert.inc [[SELECT tt1.a * 10 + value FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return "0,1,2,10,11,12,20,21,22"]
EXPLAIN SELECT tt1.a * 10 + value FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`a` * 10) + `tt2`.`value`) AS `tt1.a * 10 + value` from `test`.`t1` join sequence_table(3) `tt2`
EXPLAIN FORMAT=TREE SELECT tt1.a * 10 + value FROM (SELECT * FROM t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
EXPLAIN
-> Inner hash join (no condition)
    -> Table scan on t1  (cost=0.275 rows=3)
    -> Hash
        -> Materialize table function


# Join with derived TABLE
### SELECT tt1.a * 10 + value FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2 ###
SELECT tt1.a * 10 + value FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
tt1.a * 10 + value
2
1
0
12
11
10
22
21
20
include/assert.inc [[SELECT COUNT(*) FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return 9 records]
include/assert.inc [[SELECT tt1.a * 10 + value FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2] should return "0,1,2,10,11,12,20,21,22"]
EXPLAIN SELECT tt1.a * 10 + value FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`a` * 10) + `tt2`.`value`) AS `tt1.a * 10 + value` from `test`.`t1` join sequence_table(3) `tt2`
EXPLAIN FORMAT=TREE SELECT tt1.a * 10 + value FROM (TABLE t1) AS tt1, SEQUENCE_TABLE(3) AS tt2;
EXPLAIN
-> Inner hash join (no condition)
    -> Table scan on t1  (cost=0.275 rows=3)
    -> Hash
        -> Materialize table function


# Dependent upper_bound
### SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(a + 1) AS tt ###
SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(a + 1) AS tt;
t1.a * 10 + value
0
10
11
20
21
22
include/assert.inc [[SELECT COUNT(*) FROM t1, SEQUENCE_TABLE(a + 1) AS tt] should return 6 records]
include/assert.inc [[SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(a + 1) AS tt] should return "0,10,11,20,21,22"]
EXPLAIN SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(a + 1) AS tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: sequence_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`a` * 10) + `tt`.`value`) AS `t1.a * 10 + value` from `test`.`t1` join sequence_table((`test`.`t1`.`a` + 1)) `tt`
EXPLAIN FORMAT=TREE SELECT t1.a * 10 + value FROM t1, SEQUENCE_TABLE(a + 1) AS tt;
EXPLAIN
-> Nested loop inner join
    -> Table scan on t1  (cost=0.55 rows=3)
    -> Materialize table function


###
### Checking for various forbidden upper_bound constructs
###
# Derived SELECT
SELECT * FROM SEQUENCE_TABLE((SELECT 1)) AS tt;
ERROR HY000: Incorrect arguments to SEQUENCE_TABLE
# Aggregate function
SELECT * FROM SEQUENCE_TABLE(SUM(1)) AS tt;
ERROR HY000: Invalid use of group function
DROP TABLE t1;
