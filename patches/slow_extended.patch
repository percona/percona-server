# name       : slow_extended.patch
# introduced : 11 or before
# maintainer : Oleg
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- a/include/mysql/plugin.h
+++ b/include/mysql/plugin.h
@@ -696,6 +696,17 @@
 /* Increments the row counter, see THD::row_count */
 void thd_inc_row_count(MYSQL_THD thd);
 
+void increment_thd_innodb_stats(MYSQL_THD thd,
+                    unsigned long long trx_id,
+                    long io_reads,
+                    long long io_read,
+                    long io_reads_wait_timer,
+                    long lock_que_wait_timer,
+                    long que_wait_timer,
+                    long page_access);
+unsigned long thd_log_slow_verbosity(const MYSQL_THD thd);
+int thd_opt_slow_log();
+#define EXTENDED_SLOWLOG
 /**
   Create a temporary file.
 
--- a/include/mysql/plugin.h.pp
+++ b/include/mysql/plugin.h.pp
@@ -122,6 +122,16 @@
 char *thd_security_context(void* thd, char *buffer, unsigned int length,
                            unsigned int max_query_len);
 void thd_inc_row_count(void* thd);
+void increment_thd_innodb_stats(void* thd,
+                    unsigned long long trx_id,
+                    long io_reads,
+                    long long io_read,
+                    long io_reads_wait_timer,
+                    long lock_que_wait_timer,
+                    long que_wait_timer,
+                    long page_access);
+unsigned long thd_log_slow_verbosity(const void* thd);
+int thd_opt_slow_log();
 int mysql_tmpfile(const char *prefix);
 int thd_killed(const void* thd);
 unsigned long thd_get_thread_id(const void* thd);
--- /dev/null
+++ b/patch_info/slow_extended.info
@@ -0,0 +1,24 @@
+File=slow_extended.patch
+Name=Extended statistics in slow.log (not InnoDB part)
+Version=1.3
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+Changelog
+2008-11-26
+YK: Fix inefficient determination of trx, Make not to call useless gettimeofday when don't use slow log. Make log_slow_queries dynamic (bool).
+
+2008-11-07
+VT: Moved log_slow_rate_limit in SHOW VARIABLE into right place
+
+2008-11
+Arjen Lentz: Fixups (backward compatibility) by Arjen Lentz <arjen@openquery.com.au>
+
+2010-07
+1) Fix overflow of query time and lock time (Bug 600360) (slow_extended_fix_overflow.patch merged)
+2) Control global slow feature merged (control_global_slow.patch merged)
+3) Microseconds in slow query log merged (microseconds_in_slow_query_log.patch merged)
+4) Now use_global_long_query_time and use_global_log_slow_control are synonims. Add value "all" for use_global_log_slow_control (contol-global_slow-2.patch merged)
+5) Fix innodb_stats on replication (Bug 600684)
+6) Change variable types (system/command-line)
+
--- a/scripts/mysqldumpslow.sh
+++ b/scripts/mysqldumpslow.sh
@@ -102,8 +102,8 @@
     s/^#? Time: \d{6}\s+\d+:\d+:\d+.*\n//;
     my ($user,$host) = s/^#? User\@Host:\s+(\S+)\s+\@\s+(\S+).*\n// ? ($1,$2) : ('','');
 
-    s/^# Query_time: ([0-9.]+)\s+Lock_time: ([0-9.]+)\s+Rows_sent: ([0-9.]+).*\n//;
-    my ($t, $l, $r) = ($1, $2, $3);
+    s/^# Query_time: (\d+(\.\d+)?)  Lock_time: (\d+(\.\d+)?)  Rows_sent: (\d+(\.\d+)?).*\n//;
+    my ($t, $l, $r)= ($1, $3, $5);
     $t -= $l unless $opt{l};
 
     # remove fluff that mysqld writes to log when it (re)starts:
--- a/sql/event_scheduler.cc
+++ b/sql/event_scheduler.cc
@@ -196,6 +196,7 @@
   thd->client_capabilities|= CLIENT_MULTI_RESULTS;
   pthread_mutex_lock(&LOCK_thread_count);
   thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;
+  thd->write_to_slow_log= TRUE;
   pthread_mutex_unlock(&LOCK_thread_count);
 
   /*
--- a/sql/filesort.cc
+++ b/sql/filesort.cc
@@ -192,6 +192,7 @@
   {
     status_var_increment(thd->status_var.filesort_scan_count);
   }
+  thd->query_plan_flags|= QPLAN_FILESORT;
 #ifdef CAN_TRUST_RANGE
   if (select && select->quick && select->quick->records > 0L)
   {
@@ -257,6 +258,7 @@
   }
   else
   {
+    thd->query_plan_flags|= QPLAN_FILESORT_DISK;
     if (table_sort.buffpek && table_sort.buffpek_len < maxbuffer)
     {
       x_free(table_sort.buffpek);
@@ -1205,6 +1207,7 @@
   DBUG_ENTER("merge_buffers");
 
   status_var_increment(current_thd->status_var.filesort_merge_passes);
+  current_thd->query_plan_fsort_passes++;
   if (param->not_killable)
   {
     killed= &not_killable;
--- a/sql/log.cc
+++ b/sql/log.cc
@@ -524,11 +524,13 @@
 */
 
 bool Log_to_csv_event_handler::
-  log_slow(THD *thd, time_t current_time, time_t query_start_arg,
+  log_slow(THD *thd, ulonglong current_utime, time_t query_start_arg,
            const char *user_host, uint user_host_len,
            ulonglong query_utime, ulonglong lock_utime, bool is_command,
            const char *sql_text, uint sql_text_len)
 {
+  time_t current_time= my_time_possible_from_micro(current_utime);
+
   TABLE_LIST table_list;
   TABLE *table;
   bool result= TRUE;
@@ -754,14 +756,14 @@
 /** Wrapper around MYSQL_LOG::write() for slow log. */
 
 bool Log_to_file_event_handler::
-  log_slow(THD *thd, time_t current_time, time_t query_start_arg,
+  log_slow(THD *thd, ulonglong current_utime, time_t query_start_arg,
            const char *user_host, uint user_host_len,
            ulonglong query_utime, ulonglong lock_utime, bool is_command,
            const char *sql_text, uint sql_text_len)
 {
   Silence_log_table_errors error_handler;
   thd->push_internal_handler(&error_handler);
-  bool retval= mysql_slow_log.write(thd, current_time, query_start_arg,
+  bool retval= mysql_slow_log.write(thd, current_utime, query_start_arg,
                                     user_host, user_host_len,
                                     query_utime, lock_utime, is_command,
                                     sql_text, sql_text_len);
@@ -987,7 +989,7 @@
     /* fill in user_host value: the format is "%s[%s] @ %s [%s]" */
     user_host_len= (strxnmov(user_host_buff, MAX_USER_HOST_SIZE,
                              sctx->priv_user ? sctx->priv_user : "", "[",
-                             sctx->user ? sctx->user : "", "] @ ",
+                             sctx->user ? sctx->user : (thd->slave_thread ? "SQL_SLAVE" : ""), "] @ ",
                              sctx->host ? sctx->host : "", " [",
                              sctx->ip ? sctx->ip : "", "]", NullS) -
                     user_host_buff);
@@ -995,9 +997,23 @@
     current_time= my_time_possible_from_micro(current_utime);
     if (thd->start_utime)
     {
+      if(current_utime < thd->start_utime)
+      {
+        query_utime= 0;
+      }
+      else
+      {
       query_utime= (current_utime - thd->start_utime);
+      }
+      if(thd->utime_after_lock < thd->start_utime)
+      {
+        lock_utime= 0;
+      }
+      else
+      {
       lock_utime=  (thd->utime_after_lock - thd->start_utime);
     }
+    }
     else
     {
       query_utime= lock_utime= 0;
@@ -1010,8 +1026,21 @@
       query_length= command_name[thd->command].length;
     }
 
+    if (!query_length)
+    {
+      thd->sent_row_count= thd->examined_row_count= 0;
+      thd->row_count= 0;
+      thd->orig_row_count= 0;
+      thd->bytes_sent_old= thd->status_var.bytes_sent;
+      thd->tmp_tables_used= thd->tmp_tables_disk_used= 0;
+      thd->tmp_tables_size= 0;
+      thd->innodb_was_used= FALSE;
+      thd->query_plan_flags= QPLAN_NONE;
+      thd->query_plan_fsort_passes= 0;
+    }
+
     for (current_handler= slow_log_handler_list; *current_handler ;)
-      error= (*current_handler++)->log_slow(thd, current_time, thd->start_time,
+      error= (*current_handler++)->log_slow(thd, current_utime, thd->start_time,
                                             user_host_buff, user_host_len,
                                             query_utime, lock_utime, is_command,
                                             query, query_length) || error;
@@ -2282,12 +2311,13 @@
     TRUE - error occured
 */
 
-bool MYSQL_QUERY_LOG::write(THD *thd, time_t current_time,
+bool MYSQL_QUERY_LOG::write(THD *thd, ulonglong current_utime,
                             time_t query_start_arg, const char *user_host,
                             uint user_host_len, ulonglong query_utime,
                             ulonglong lock_utime, bool is_command,
                             const char *sql_text, uint sql_text_len)
 {
+  time_t current_time= my_time_possible_from_micro(current_utime);
   bool error= 0;
   DBUG_ENTER("MYSQL_QUERY_LOG::write");
 
@@ -2309,17 +2339,28 @@
 
     if (!(specialflag & SPECIAL_SHORT_LOG_FORMAT))
     {
-      if (current_time != last_time)
+      if (opt_log_slow_timestamp_every || current_time != last_time)
       {
         last_time= current_time;
         struct tm start;
         localtime_r(&current_time, &start);
-
+	if(opt_slow_query_log_microseconds_timestamp)
+	{
+	  ulonglong microsecond = current_utime % (1000 * 1000);
+	  buff_len= snprintf(buff, sizeof buff,
+	    "# Time: %02d%02d%02d %2d:%02d:%02d.%010lld\n",
+            start.tm_year % 100, start.tm_mon + 1,
+	    start.tm_mday, start.tm_hour,
+	    start.tm_min, start.tm_sec,microsecond);
+	}
+	else
+	{
         buff_len= my_snprintf(buff, sizeof buff,
                               "# Time: %02d%02d%02d %2d:%02d:%02d\n",
                               start.tm_year % 100, start.tm_mon + 1,
                               start.tm_mday, start.tm_hour,
                               start.tm_min, start.tm_sec);
+	}
 
         /* Note that my_b_write() assumes it knows the length for this */
         if (my_b_write(&log_file, (uchar*) buff, buff_len))
@@ -2337,12 +2378,64 @@
     sprintf(query_time_buff, "%.6f", ulonglong2double(query_utime)/1000000.0);
     sprintf(lock_time_buff,  "%.6f", ulonglong2double(lock_utime)/1000000.0);
     if (my_b_printf(&log_file,
-                    "# Query_time: %s  Lock_time: %s"
-                    " Rows_sent: %lu  Rows_examined: %lu\n",
+                    "# Thread_id: %lu  Schema: %s  Last_errno: %u  Killed: %u\n" \
+                    "# Query_time: %s  Lock_time: %s  Rows_sent: %lu  Rows_examined: %lu  Rows_affected: %lu  Rows_read: %lu\n"
+                    "# Bytes_sent: %lu  Tmp_tables: %lu  Tmp_disk_tables: %lu  Tmp_table_sizes: %lu\n",
+                    (ulong) thd->thread_id, (thd->db ? thd->db : ""),
+                    thd->last_errno, (uint) thd->killed,
                     query_time_buff, lock_time_buff,
                     (ulong) thd->sent_row_count,
-                    (ulong) thd->examined_row_count) == (uint) -1)
+                    (ulong) thd->examined_row_count,
+                    ((long) thd->row_count_func > 0 ) ? (ulong) thd->row_count_func : 0,
+                    thd->row_count - thd->orig_row_count + 1,
+                    (ulong) (thd->status_var.bytes_sent - thd->bytes_sent_old),
+                    (ulong) thd->tmp_tables_used,
+                    (ulong) thd->tmp_tables_disk_used,
+                    (ulong) thd->tmp_tables_size) == (uint) -1)
+      tmp_errno= errno;
+    if (thd->innodb_was_used)
+    {
+      char buf[20];
+      snprintf(buf, 20, "%llX", thd->innodb_trx_id);
+      if (my_b_printf(&log_file,
+                    "# InnoDB_trx_id: %s\n", buf) == (uint) -1)
+        tmp_errno=errno;
+    }
+    if ((thd->variables.log_slow_verbosity & SLOG_V_QUERY_PLAN) &&
+         my_b_printf(&log_file,
+                    "# QC_Hit: %s  Full_scan: %s  Full_join: %s  Tmp_table: %s  Tmp_table_on_disk: %s\n" \
+                    "# Filesort: %s  Filesort_on_disk: %s  Merge_passes: %lu\n",
+                    ((thd->query_plan_flags & QPLAN_QC) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_FULL_SCAN) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_FULL_JOIN) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_TMP_TABLE) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_TMP_DISK) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_FILESORT) ? "Yes" : "No"),
+                    ((thd->query_plan_flags & QPLAN_FILESORT_DISK) ? "Yes" : "No"),
+                    thd->query_plan_fsort_passes) == (uint) -1)
+      tmp_errno=errno;
+    if ((thd->variables.log_slow_verbosity & SLOG_V_INNODB) && thd->innodb_was_used)
+    {
+      char buf[3][20];
+      snprintf(buf[0], 20, "%.6f", thd->innodb_io_reads_wait_timer / 1000000.0);
+      snprintf(buf[1], 20, "%.6f", thd->innodb_lock_que_wait_timer / 1000000.0);
+      snprintf(buf[2], 20, "%.6f", thd->innodb_innodb_que_wait_timer / 1000000.0);
+      if (my_b_printf(&log_file,
+                      "#   InnoDB_IO_r_ops: %lu  InnoDB_IO_r_bytes: %lu  InnoDB_IO_r_wait: %s\n" \
+                      "#   InnoDB_rec_lock_wait: %s  InnoDB_queue_wait: %s\n" \
+                      "#   InnoDB_pages_distinct: %lu\n",
+                      (ulong) thd->innodb_io_reads,
+                      (ulong) thd->innodb_io_read,
+                      buf[0], buf[1], buf[2],
+                      (ulong) thd->innodb_page_access) == (uint) -1)
+        tmp_errno= errno;
+    } 
+    else
+    {
+      if ((thd->variables.log_slow_verbosity & SLOG_V_INNODB) &&
+          my_b_printf(&log_file,"# No InnoDB statistics available for this query\n") == (uint) -1)
       tmp_errno= errno;
+    }
     if (thd->db && strcmp(thd->db, db))
     {						// Database changed
       if (my_b_printf(&log_file,"use %s;\n",thd->db) == (uint) -1)
--- a/sql/log.h
+++ b/sql/log.h
@@ -213,7 +213,7 @@
              uint user_host_len, int thread_id,
              const char *command_type, uint command_type_len,
              const char *sql_text, uint sql_text_len);
-  bool write(THD *thd, time_t current_time, time_t query_start_arg,
+  bool write(THD *thd, ulonglong current_utime, time_t query_start_arg,
              const char *user_host, uint user_host_len,
              ulonglong query_utime, ulonglong lock_utime, bool is_command,
              const char *sql_text, uint sql_text_len);
@@ -427,7 +427,7 @@
   virtual bool init()= 0;
   virtual void cleanup()= 0;
 
-  virtual bool log_slow(THD *thd, time_t current_time,
+  virtual bool log_slow(THD *thd, ulonglong current_utime,
                         time_t query_start_arg, const char *user_host,
                         uint user_host_len, ulonglong query_utime,
                         ulonglong lock_utime, bool is_command,
@@ -456,7 +456,7 @@
   virtual bool init();
   virtual void cleanup();
 
-  virtual bool log_slow(THD *thd, time_t current_time,
+  virtual bool log_slow(THD *thd, ulonglong current_utime,
                         time_t query_start_arg, const char *user_host,
                         uint user_host_len, ulonglong query_utime,
                         ulonglong lock_utime, bool is_command,
@@ -488,7 +488,7 @@
   virtual bool init();
   virtual void cleanup();
 
-  virtual bool log_slow(THD *thd, time_t current_time,
+  virtual bool log_slow(THD *thd, ulonglong current_utime,
                         time_t query_start_arg, const char *user_host,
                         uint user_host_len, ulonglong query_utime,
                         ulonglong lock_utime, bool is_command,
--- a/sql/log_event.cc
+++ b/sql/log_event.cc
@@ -2368,6 +2368,15 @@
       start+= host.length;
     }
   }
+#ifndef DBUG_OFF
+  if (thd && thd->variables.query_exec_time > 0)
+  {
+    *start++= Q_QUERY_EXEC_TIME;;
+    int8store(start, thd->variables.query_exec_time);
+    start+= 8;
+  }
+#endif
+
   /*
     NOTE: When adding new status vars, please don't forget to update
     the MAX_SIZE_LOG_EVENT_STATUS in log_event.h and update the function
@@ -2797,6 +2806,17 @@
       data_written= master_data_written= uint4korr(pos);
       pos+= 4;
       break;
+#if !defined(DBUG_OFF) && !defined(MYSQL_CLIENT)
+    case Q_QUERY_EXEC_TIME:
+    {
+      THD *thd= current_thd;
+      CHECK_SPACE(pos, end, 8);
+      if (thd)
+        thd->variables.query_exec_time= uint8korr(pos);
+      pos+= 8;
+      break;
+    }
+#endif
     case Q_INVOKER:
     {
       CHECK_SPACE(pos, end, 1);
@@ -3097,6 +3117,7 @@
   LEX_STRING new_db;
   int expected_error,actual_error= 0;
   HA_CREATE_INFO db_options;
+  bool process_log_slow_statement= false;
 
   /*
     Colleagues: please never free(thd->catalog) in MySQL. This would
@@ -3278,19 +3299,7 @@
       /* Execute the query (note that we bypass dispatch_command()) */
       const char* found_semicolon= NULL;
       mysql_parse(thd, thd->query(), thd->query_length(), &found_semicolon);
-      log_slow_statement(thd);
-
-      /*
-        Resetting the enable_slow_log thd variable.
-
-        We need to reset it back to the opt_log_slow_slave_statements
-        value after the statement execution (and slow logging
-        is done). It might have changed if the statement was an
-        admin statement (in which case, down in mysql_parse execution
-        thd->enable_slow_log is set to the value of
-        opt_log_slow_admin_statements).
-      */
-      thd->enable_slow_log= opt_log_slow_slave_statements;
+      process_log_slow_statement= true;
     }
     else
     {
@@ -3435,11 +3444,27 @@
     don't suffer from these assignments to 0 as DROP TEMPORARY
     TABLE uses the db.table syntax.
   */
+  close_thread_tables(thd);      
+  if(process_log_slow_statement)
+  {
+      log_slow_statement(thd);
+
+      /*
+        Resetting the enable_slow_log thd variable.
+
+        We need to reset it back to the opt_log_slow_slave_statements
+        value after the statement execution (and slow logging
+        is done). It might have changed if the statement was an
+        admin statement (in which case, down in mysql_parse execution
+        thd->enable_slow_log is set to the value of
+        opt_log_slow_admin_statements).
+      */
+      thd->enable_slow_log= opt_log_slow_slave_statements;
+  }
   thd->catalog= 0;
   thd->set_db(NULL, 0);                 /* will free the current database */
   thd->set_query(NULL, 0);
   DBUG_PRINT("info", ("end: query= 0"));
-  close_thread_tables(thd);      
   /*
     As a disk space optimization, future masters will not log an event for
     LAST_INSERT_ID() if that function returned 0 (and thus they will be able
--- a/sql/mysql_priv.h
+++ b/sql/mysql_priv.h
@@ -640,6 +640,106 @@
 
 #define STRING_BUFFER_USUAL_SIZE 80
 
+/* Slow log */
+
+struct msl_opts
+{
+  ulong val;
+  const char *name;
+};
+
+/* use global log slow control */
+#define SLOG_UG_NONE                        (1UL << 0)
+#define SLOG_UG_LOG_SLOW_FILTER             (1UL << 1)
+#define SLOG_UG_LOG_SLOW_RATE_LIMIT         (1UL << 2)
+#define SLOG_UG_LOG_SLOW_VERBOSITY          (1UL << 3)
+#define SLOG_UG_LONG_QUERY_TIME             (1UL << 4)
+#define SLOG_UG_MIN_EXAMINED_ROW_LIMIT      (1UL << 5)
+#define SLOG_UG_ALL                         SLOG_UG_LOG_SLOW_FILTER | SLOG_UG_LOG_SLOW_RATE_LIMIT | SLOG_UG_LOG_SLOW_VERBOSITY | SLOG_UG_LONG_QUERY_TIME | SLOG_UG_MIN_EXAMINED_ROW_LIMIT
+/* ... */
+#define SLOG_UG_INVALID                     1##UL << 31
+
+static const struct msl_opts slog_use_global[]=
+  {
+    /* Basic flags */
+    { SLOG_UG_NONE                      , "none" },
+    { SLOG_UG_LOG_SLOW_FILTER           , "log_slow_filter" },
+    { SLOG_UG_LOG_SLOW_RATE_LIMIT       , "log_slow_rate_limit" },
+    { SLOG_UG_LOG_SLOW_VERBOSITY        , "log_slow_verbosity" },
+    { SLOG_UG_LONG_QUERY_TIME           , "long_query_time" },
+    { SLOG_UG_MIN_EXAMINED_ROW_LIMIT    , "min_examined_row_limit" },
+    /* ... */
+    { 0, "" },
+    /* Complex flags */
+    { SLOG_UG_ALL                       , "all" },
+    /* ... */
+    { SLOG_UG_INVALID                   , (char*)0 }
+  };
+
+#define SLOG_V_MICROTIME      1 << 0
+#define SLOG_V_QUERY_PLAN     1 << 1
+#define SLOG_V_INNODB         1 << 2
+/* ... */
+#define SLOG_V_INVALID        1##UL << 31
+#define SLOG_V_NONE           SLOG_V_MICROTIME
+
+static const struct msl_opts slog_verb[]= 
+{
+  /* Basic flags */
+
+  { SLOG_V_MICROTIME, "microtime" },
+  { SLOG_V_QUERY_PLAN, "query_plan" },
+  { SLOG_V_INNODB, "innodb" },
+
+  /* End of baisc flags */
+
+  { 0, "" },
+
+  /* Complex flags */
+
+  { SLOG_V_MICROTIME, "minimal" },
+  { SLOG_V_MICROTIME|SLOG_V_QUERY_PLAN, "standard" },
+  { SLOG_V_MICROTIME|SLOG_V_QUERY_PLAN|SLOG_V_INNODB, "full" },
+
+  /* End of complex flags */
+
+  { SLOG_V_INVALID, (char *)0 }
+};
+
+#define QPLAN_NONE            0
+#define QPLAN_QC              1 << 0
+#define QPLAN_QC_NO           1 << 1
+#define QPLAN_FULL_SCAN       1 << 2
+#define QPLAN_FULL_JOIN       1 << 3
+#define QPLAN_TMP_TABLE       1 << 4
+#define QPLAN_TMP_DISK        1 << 5
+#define QPLAN_FILESORT        1 << 6
+#define QPLAN_FILESORT_DISK   1 << 7
+/* ... */
+#define QPLAN_MAX             1 << 31
+
+#define SLOG_F_QC_NO          QPLAN_QC_NO
+#define SLOG_F_FULL_SCAN      QPLAN_FULL_SCAN
+#define SLOG_F_FULL_JOIN      QPLAN_FULL_JOIN
+#define SLOG_F_TMP_TABLE      QPLAN_TMP_TABLE
+#define SLOG_F_TMP_DISK       QPLAN_TMP_DISK
+#define SLOG_F_FILESORT       QPLAN_FILESORT
+#define SLOG_F_FILESORT_DISK  QPLAN_FILESORT_DISK
+#define SLOG_F_INVALID        1##UL << 31
+#define SLOG_F_NONE           0
+
+static const struct msl_opts slog_filter[]= 
+{
+  { SLOG_F_QC_NO,         "qc_miss" },
+  { SLOG_F_FULL_SCAN,     "full_scan" },
+  { SLOG_F_FULL_JOIN,     "full_join" },
+  { SLOG_F_TMP_TABLE,     "tmp_table" },
+  { SLOG_F_TMP_DISK,      "tmp_table_on_disk" },
+  { SLOG_F_FILESORT,      "filesort" },
+  { SLOG_F_FILESORT_DISK, "filesort_on_disk" },
+  { SLOG_F_INVALID,       (char *)0 }
+};
+
 /*
   Some defines for exit codes for ::is_equal class functions.
 */
@@ -2001,6 +2101,10 @@
 extern my_bool opt_secure_auth;
 extern char* opt_secure_file_priv;
 extern my_bool opt_log_slow_admin_statements, opt_log_slow_slave_statements;
+extern my_bool opt_log_slow_sp_statements;
+extern my_bool opt_log_slow_timestamp_every;
+extern my_bool opt_use_global_long_query_time;
+extern my_bool opt_slow_query_log_microseconds_timestamp;
 extern my_bool sp_automatic_privileges, opt_noacl;
 extern my_bool opt_old_style_user_limits, trust_function_creators;
 extern uint opt_crash_binlog_innodb;
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -443,6 +443,7 @@
 static char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;
 static I_List<THD> thread_cache;
 static double long_query_time;
+static double query_exec_time;
 
 static pthread_cond_t COND_thread_cache, COND_flush_thread_cache;
 
@@ -528,6 +529,10 @@
 char* opt_secure_file_priv= 0;
 my_bool opt_log_slow_admin_statements= 0;
 my_bool opt_log_slow_slave_statements= 0;
+my_bool opt_log_slow_sp_statements= 0;
+my_bool opt_log_slow_timestamp_every= 0;
+my_bool opt_use_global_long_query_time= 0;
+my_bool opt_slow_query_log_microseconds_timestamp= 0;
 my_bool lower_case_file_system= 0;
 my_bool opt_large_pages= 0;
 my_bool opt_myisam_use_mmap= 0;
@@ -5811,7 +5816,13 @@
   OPT_INNODB_ROLLBACK_ON_TIMEOUT,
   OPT_SECURE_FILE_PRIV,
   OPT_MIN_EXAMINED_ROW_LIMIT,
+  OPT_QUERY_EXEC_TIME,
   OPT_LOG_SLOW_SLAVE_STATEMENTS,
+  OPT_LOG_SLOW_RATE_LIMIT,
+  OPT_LOG_SLOW_VERBOSITY,
+  OPT_LOG_SLOW_FILTER,
+  OPT_LOG_SLOW_SP_STATEMENTS,
+  OPT_LOG_SLOW_TIMESTAMP_EVERY,
 #if defined(ENABLED_DEBUG_SYNC)
   OPT_DEBUG_SYNC_TIMEOUT,
 #endif /* defined(ENABLED_DEBUG_SYNC) */
@@ -5819,6 +5830,9 @@
   OPT_SLAVE_EXEC_MODE,
   OPT_GENERAL_LOG_FILE,
   OPT_SLOW_QUERY_LOG_FILE,
+  OPT_USE_GLOBAL_LONG_QUERY_TIME,
+  OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
+  OPT_SLOW_QUERY_LOG_MICROSECONDS_TIMESTAMP,
   OPT_IGNORE_BUILTIN_INNODB,
   OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
   OPT_DEFAULT_CHARACTER_SET_OLD,
@@ -6839,6 +6853,36 @@
    "microsecond precision.",
    &long_query_time, &long_query_time, 0, GET_DOUBLE,
    REQUIRED_ARG, 10, 0, LONG_TIMEOUT, 0, 0, 0},
+  {"log_slow_filter", OPT_LOG_SLOW_FILTER,
+    "Log only the queries that followed certain execution plan. Multiple flags allowed in a comma-separated string. [qc_miss, full_scan, full_join, tmp_table, tmp_table_on_disk, filesort, filesort_on_disk]",
+    0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, SLOG_F_NONE, 0, 0},
+  {"log_slow_rate_limit", OPT_LOG_SLOW_RATE_LIMIT,
+    "Rate limit statement writes to slow log to only those from every (1/log_slow_rate_limit) session.",
+    (uchar**) &global_system_variables.log_slow_rate_limit,
+    (uchar**) &max_system_variables.log_slow_rate_limit, 0, GET_ULONG,
+    REQUIRED_ARG, 1, 1, LONG_MAX, 0, 1L, 0},
+  {"log_slow_verbosity", OPT_LOG_SLOW_VERBOSITY,
+    "Choose how verbose the messages to your slow log will be. Multiple flags allowed in a comma-separated string. [microtime, query_plan, innodb]",
+    0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, SLOG_V_MICROTIME, 0, 0},
+  {"log_slow_sp_statements", OPT_LOG_SLOW_SP_STATEMENTS,
+   "Log slow statements executed by stored procedure to the slow log if it is open.",
+   (uchar**) &opt_log_slow_sp_statements, (uchar**) &opt_log_slow_sp_statements,
+   0, GET_BOOL, OPT_ARG, 1, 0, 1, 0, 1, 0},
+  {"log_slow_timestamp_every", OPT_LOG_SLOW_TIMESTAMP_EVERY,
+   "Timestamp is printed for all records of the slow log even if they are same time.",
+   (uchar**) &opt_log_slow_timestamp_every, (uchar**) &opt_log_slow_timestamp_every,
+   0, GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},
+  {"use_global_log_slow_control", OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
+    "Choose flags, wich always use the global variables. Multiple flags allowed in a comma-separated string. [none, log_slow_filter, log_slow_rate_limit, log_slow_verbosity, long_query_time, min_examined_row_limit, all]",
+   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, SLOG_UG_NONE, 0, 0},
+  {"use_global_long_query_time", OPT_USE_GLOBAL_LONG_QUERY_TIME,
+   "Control always use global long_query_time or local long_query_time.",
+   (uchar**) &opt_use_global_long_query_time, (uchar**) &opt_use_global_long_query_time,
+   0, GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},
+  {"slow_query_log_microseconds_timestamp", OPT_SLOW_QUERY_LOG_MICROSECONDS_TIMESTAMP,
+   "Use microsecond time's precision in slow query log",
+   (uchar**) &opt_slow_query_log_microseconds_timestamp, (uchar**) &opt_slow_query_log_microseconds_timestamp,
+   0, GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},
   {"lower_case_table_names", OPT_LOWER_CASE_TABLE_NAMES,
    "If set to 1, table names are stored in lowercase on disk and table names "
    "will be case-insensitive.  Should be set to 2 if you are using a case-"
@@ -7076,6 +7120,13 @@
    "is the plugin library in plugin_dir.",
    &opt_plugin_load, &opt_plugin_load, 0,
    GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+#ifndef DBUG_OFF
+  {"query_exec_time", OPT_QUERY_EXEC_TIME,
+   "Pretend queries take this many seconds. When 0 (the default) use the "
+   "actual execution time. Used only for debugging.",
+   &query_exec_time, &query_exec_time, 0, GET_DOUBLE,
+   REQUIRED_ARG, 0, 0, LONG_TIMEOUT, 0, 0, 0},
+#endif
   {"preload_buffer_size", OPT_PRELOAD_BUFFER_SIZE,
    "The size of the buffer that is allocated when preloading indexes.",
    &global_system_variables.preload_buff_size,
@@ -7991,6 +8042,10 @@
   global_system_variables.old_passwords= 0;
   global_system_variables.old_alter_table= 0;
   global_system_variables.binlog_format= BINLOG_FORMAT_UNSPEC;
+
+  global_system_variables.log_slow_verbosity= SLOG_V_MICROTIME;
+  global_system_variables.use_global_log_slow_control= SLOG_UG_NONE;
+  global_system_variables.log_slow_filter= SLOG_F_NONE;
   /*
     Default behavior for 4.1 and 5.0 is to treat NULL values as unequal
     when collecting index statistics for MyISAM tables.
@@ -8494,6 +8549,44 @@
   case OPT_BOOTSTRAP:
     opt_noacl=opt_bootstrap=1;
     break;
+  case OPT_LOG_SLOW_FILTER:
+    if ((global_system_variables.log_slow_filter= 
+          msl_flag_resolve_by_name(slog_filter, argument,
+                                   SLOG_F_NONE, SLOG_F_INVALID)) == SLOG_F_INVALID)
+    {
+      fprintf(stderr,"Invalid argument in log_slow_filter: %s\n", argument);
+      exit(1);
+    }
+    break;
+  case OPT_LOG_SLOW_VERBOSITY:
+    if ((global_system_variables.log_slow_verbosity= 
+         msl_flag_resolve_by_name(slog_verb, argument,
+                                  SLOG_V_NONE, SLOG_V_INVALID)) == SLOG_V_INVALID)
+    {
+      fprintf(stderr,"Invalid argument in log_slow_verbosity: %s\n", argument);
+      exit(1);
+    }
+    break;
+  case OPT_USE_GLOBAL_LONG_QUERY_TIME:
+    use_global_long_query_time_update(opt_use_global_long_query_time);
+    break;
+  case OPT_USE_GLOBAL_LOG_SLOW_CONTROL:
+    {
+      ulong &v= global_system_variables.use_global_log_slow_control;
+      v= msl_flag_resolve_by_name(slog_use_global, argument, SLOG_UG_NONE, SLOG_UG_INVALID);
+      if (v != SLOG_UG_NONE)
+      {
+        v&= ~SLOG_UG_NONE;
+      }
+      if (v == SLOG_UG_INVALID)
+      {
+        fprintf(stderr,"Invalid argument in use_global_log_slow_control: %s\n", argument);
+        exit(1);
+      }
+      use_global_long_query_time_update
+        (global_system_variables.use_global_log_slow_control & SLOG_UG_LONG_QUERY_TIME);
+      break;
+    }
   case OPT_SERVER_ID:
     server_id_supplied = 1;
     break;
--- a/sql/set_var.cc
+++ b/sql/set_var.cc
@@ -164,6 +164,74 @@
 
 static sys_var_chain vars = { NULL, NULL };
 
+void use_global_long_query_time_update(bool enable)
+{
+  ulong &log_slow_control= global_system_variables.use_global_log_slow_control;
+  opt_use_global_long_query_time= enable;
+  if (enable)
+    log_slow_control|= SLOG_UG_LONG_QUERY_TIME;
+  else
+    log_slow_control&= ~SLOG_UG_LONG_QUERY_TIME;
+  log_slow_control&= ~SLOG_UG_NONE;
+  if (log_slow_control == 0)
+    log_slow_control= SLOG_UG_NONE;
+}
+
+class sys_var_use_global_long_query_time : public sys_var_bool_ptr
+{
+public:
+  sys_var_use_global_long_query_time()
+    :sys_var_bool_ptr(&vars,"use_global_long_query_time",&opt_use_global_long_query_time)
+  {
+    chain_sys_var(&vars);
+  }
+  virtual bool update(THD *thd, set_var *var)
+  {
+    bool result = sys_var_bool_ptr::update(thd,var);
+    sync();
+    return result;
+  }
+  virtual void set_default(THD *thd, enum_var_type type)
+  {
+    sys_var_bool_ptr::set_default(thd,type);
+    sync();
+  }
+private:
+  void sync()
+  {
+    use_global_long_query_time_update(opt_use_global_long_query_time);    
+  }
+};
+class sys_var_use_global_log_slow_control : public sys_var_thd_msl_flag_correct_none
+{
+ public:
+  sys_var_use_global_log_slow_control() : sys_var_thd_msl_flag_correct_none(
+								 &vars
+								 ,"use_global_log_slow_control"
+								 ,&SV::use_global_log_slow_control
+								 ,SLOG_UG_NONE,SLOG_UG_NONE,SLOG_UG_INVALID
+								 ,slog_use_global)
+    {
+    }
+  virtual bool update(THD *thd, set_var *var)
+  {
+    bool result = sys_var_thd_msl_flag_correct_none::update(thd,var);
+    sync();
+    return result;
+  }
+  virtual void set_default(THD *thd, enum_var_type type)
+  {
+    sys_var_thd_msl_flag_correct_none::set_default(thd,type);
+    sync();
+  }
+private:
+  void sync()
+  {
+    ulong const &variable= global_system_variables.use_global_log_slow_control;
+    use_global_long_query_time_update((variable & SLOG_UG_LONG_QUERY_TIME));
+  }
+};
+
 static sys_var_thd_ulong
 sys_auto_increment_increment(&vars, "auto_increment_increment",
                              &SV::auto_increment_increment, NULL, NULL,
@@ -903,6 +971,37 @@
                                       QUERY_LOG_GENERAL);
 static sys_var_log_state sys_var_slow_query_log(&vars, "slow_query_log", &opt_slow_log,
                                          QUERY_LOG_SLOW);
+static sys_var_thd_ulong      sys_log_slow_rate_limit(&vars, "log_slow_rate_limit",
+                                            &SV::log_slow_rate_limit);
+static sys_var_thd_msl_flag   sys_log_slow_filter(&vars, "log_slow_filter",
+                                      &SV::log_slow_filter,
+                                       SLOG_F_NONE,
+                                       SLOG_F_NONE,
+                                       SLOG_F_INVALID,
+                                       slog_filter);
+static sys_var_thd_msl_flag   sys_log_slow_verbosity(&vars, "log_slow_verbosity",
+                                      &SV::log_slow_verbosity,
+                                       SLOG_V_NONE,
+                                       SLOG_V_MICROTIME,
+                                       SLOG_V_INVALID,
+                                       slog_verb);
+static sys_var_use_global_log_slow_control sys_use_global_log_slow_control;
+static sys_var_bool_ptr       sys_log_slow_admin_statements(&vars, "log_slow_admin_statements",
+                                                            &opt_log_slow_admin_statements);
+static sys_var_bool_ptr       sys_log_slow_slave_statements(&vars, "log_slow_slave_statements",
+                                                            &opt_log_slow_slave_statements);
+static sys_var_bool_ptr       sys_log_slow_sp_statements(&vars, "log_slow_sp_statements",
+                                                         &opt_log_slow_sp_statements);
+static sys_var_bool_ptr       sys_log_slow_timestamp_every(&vars, "log_slow_timestamp_every",
+                                                           &opt_log_slow_timestamp_every);
+static sys_var_use_global_long_query_time sys_use_global_long_query_time;
+static sys_var_bool_ptr       sys_slow_query_log_microseconds_timestamp(&vars, "slow_query_log_microseconds_timestamp",
+                                                       &opt_slow_query_log_microseconds_timestamp);
+#ifndef DBUG_OFF
+static sys_var_microseconds sys_var_query_exec_time(&vars, "query_exec_time",
+                                                    &SV::query_exec_time,
+                                                    sys_var::SESSION_VARIABLE_IN_BINLOG);
+#endif
 /* Synonym of "slow_query_log" for consistency with SHOW VARIABLES output */
 static sys_var_log_state sys_var_log_slow(&vars, "log_slow_queries",
                                           &opt_slow_log, QUERY_LOG_SLOW);
@@ -3713,6 +3812,203 @@
 #endif
 }
 
+/* Slow log stuff */
+
+ulong msl_option_resolve_by_name(const struct msl_opts *opts, const char *name, ulong len)
+{
+  ulong i;
+  
+  for (i=0; opts[i].name; i++)
+  {
+    if (!my_strnncoll(&my_charset_latin1,
+                      (const uchar *)name, len,
+                      (const uchar *)opts[i].name, strlen(opts[i].name)))
+      return opts[i].val;
+  }
+  return opts[i].val;
+}
+
+ulong msl_flag_resolve_by_name(const struct msl_opts *opts, const char *names_list, 
+                               const ulong none_val, const ulong invalid_val)
+{
+  const char *p, *e;
+  ulong val= none_val;
+  
+  if (!*names_list)
+    return val;
+  
+  for (p= e= names_list; ; e++)
+  {
+    ulong i;
+    
+    if (*e != ',' && *e)
+      continue;
+    for (i=0; opts[i].name; i++)
+    {
+      if (!my_strnncoll(&my_charset_latin1,
+                        (const uchar *)p, e - p,
+                        (const uchar *)opts[i].name, strlen(opts[i].name)))
+      {
+        val= val | opts[i].val;
+        break;
+      }
+    }
+    if (opts[i].val == invalid_val)
+      return invalid_val;
+    if (!*e)
+      break;
+    p= e + 1;
+  }
+  return val;
+}
+
+const char *msl_option_get_name(const struct msl_opts *opts, ulong val)
+{
+  for (ulong i=0; opts[i].name && opts[i].name[0]; i++)
+  {
+    if (opts[i].val == val)
+      return opts[i].name;
+  }
+  return "*INVALID*";
+}
+
+char *msl_flag_get_name(const struct msl_opts *opts, char *buf, ulong val)
+{
+  uint offset= 0;
+  
+  *buf= '\0';
+  for (ulong i=0; opts[i].name && opts[i].name[0]; i++)
+  {
+    if (opts[i].val & val)
+      offset+= snprintf(buf+offset, STRING_BUFFER_USUAL_SIZE - offset - 1,
+                        "%s%s", (offset ? "," : ""), opts[i].name);
+  }
+  return buf;
+}
+
+/****************************************************************************
+ Functions to handle log_slow_verbosity
+****************************************************************************/
+
+/* Based upon sys_var::check_enum() */
+
+bool sys_var_thd_msl_option::check(THD *thd, set_var *var)
+{
+  char buff[STRING_BUFFER_USUAL_SIZE];
+  String str(buff, sizeof(buff), &my_charset_latin1), *res;
+
+  if (var->value->result_type() == STRING_RESULT)
+  {
+    ulong verb= this->invalid_val;
+    if (!(res=var->value->val_str(&str)) ||
+             (var->save_result.ulong_value=
+          (ulong) (verb= msl_option_resolve_by_name(this->opts, res->ptr(), res->length()))) == this->invalid_val)
+      goto err;
+    return 0;
+  }
+
+err:
+  my_error(ER_WRONG_ARGUMENTS, MYF(0), var->var->name);
+  return 1;
+}
+
+uchar *sys_var_thd_msl_option::value_ptr(THD *thd, enum_var_type type,
+                                       LEX_STRING *base)
+{
+  ulong val;
+  val= ((type == OPT_GLOBAL) ? global_system_variables.*offset :
+        thd->variables.*offset);
+  const char *verbosity= msl_option_get_name(this->opts, val);
+  return (uchar *) verbosity;
+}
+
+
+void sys_var_thd_msl_option::set_default(THD *thd, enum_var_type type)
+{
+  if (type == OPT_GLOBAL)
+    global_system_variables.*offset= (ulong) this->default_val;
+  else
+    thd->variables.*offset= (ulong) (global_system_variables.*offset);
+}
+
+
+bool sys_var_thd_msl_option::update(THD *thd, set_var *var)
+{
+  if (var->type == OPT_GLOBAL)
+    global_system_variables.*offset= var->save_result.ulong_value;
+  else
+    thd->variables.*offset= var->save_result.ulong_value;
+  return 0;
+}
+
+/****************************************************************************
+ Functions to handle log_slow_filter
+****************************************************************************/
+  
+/* Based upon sys_var::check_enum() */
+
+bool sys_var_thd_msl_flag::check(THD *thd, set_var *var)
+{
+  char buff[2 * STRING_BUFFER_USUAL_SIZE];
+  String str(buff, sizeof(buff), &my_charset_latin1), *res;
+
+  if (var->value->result_type() == STRING_RESULT)
+  {
+    ulong filter= this->none_val;
+    if (!(res=var->value->val_str(&str)) ||
+        (var->save_result.ulong_value=
+          (ulong) (filter= msl_flag_resolve_by_name(this->flags, res->ptr(), this->none_val, 
+                                                    this->invalid_val))) == this->invalid_val)
+      goto err;
+    return 0;
+  }
+
+err:
+  my_error(ER_WRONG_ARGUMENTS, MYF(0), var->var->name);
+  return 1;
+}
+
+uchar *sys_var_thd_msl_flag::value_ptr(THD *thd, enum_var_type type,
+                                       LEX_STRING *base)
+{
+  ulong val;
+  val= ((type == OPT_GLOBAL) ? global_system_variables.*offset :
+        thd->variables.*offset);
+  msl_flag_get_name(this->flags, this->flags_string, val);
+  return (uchar *) this->flags_string;
+}
+
+
+void sys_var_thd_msl_flag::set_default(THD *thd, enum_var_type type)
+{
+  if (type == OPT_GLOBAL)
+    global_system_variables.*offset= (ulong) this->default_val;
+  else
+    thd->variables.*offset= (ulong) (global_system_variables.*offset);
+}
+
+
+bool sys_var_thd_msl_flag::update(THD *thd, set_var *var)
+{
+  if (var->type == OPT_GLOBAL)
+    global_system_variables.*offset= var->save_result.ulong_value;
+  else
+    thd->variables.*offset= var->save_result.ulong_value;
+  return 0;
+}
+bool sys_var_thd_msl_flag_correct_none::update(THD *thd, set_var *var)
+{
+  ulong result = var->save_result.ulong_value;
+  if (result != none_val)
+    result = result & (~none_val);
+  if (var->type == OPT_GLOBAL)
+    global_system_variables.*offset = result;
+  else
+    thd->variables.*offset = result;
+  return 0;
+}
+
+
 /****************************************************************************
  Functions to handle table_type
 ****************************************************************************/
--- a/sql/set_var.h
+++ b/sql/set_var.h
@@ -569,6 +569,82 @@
 };
 
 
+extern void use_global_long_query_time_update(bool enable);
+
+class sys_var_thd_msl_option :public sys_var_thd
+{
+protected:
+  ulong SV::*offset;
+  const ulong none_val;
+  const ulong default_val;
+  const ulong invalid_val;
+  const struct msl_opts *opts;
+public:
+  sys_var_thd_msl_option(sys_var_chain *chain, const char *name_arg, ulong SV::*offset_arg,
+                         const ulong none_val_arg,
+                         const ulong default_val_arg,
+                         const ulong invalid_val_arg,
+                         const struct msl_opts *opts_arg)
+    :sys_var_thd(name_arg), offset(offset_arg), none_val(none_val_arg),
+     default_val(default_val_arg), invalid_val(invalid_val_arg), 
+     opts(opts_arg)
+  { chain_sys_var(chain); }
+  bool check(THD *thd, set_var *var);
+  SHOW_TYPE show_type() { return SHOW_CHAR; }
+  bool check_update_type(Item_result type)
+  {
+    return type != STRING_RESULT;              /* Only accept strings */
+  }
+  void set_default(THD *thd, enum_var_type type);
+  bool update(THD *thd, set_var *var);
+  uchar *value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);
+};
+
+
+class sys_var_thd_msl_flag :public sys_var_thd
+{
+protected:
+  char flags_string[2 * STRING_BUFFER_USUAL_SIZE];
+  ulong SV::*offset;
+  const ulong none_val;
+  const ulong default_val;
+  const ulong invalid_val;
+  const struct msl_opts *flags;
+public:
+  sys_var_thd_msl_flag(sys_var_chain *chain, const char *name_arg, ulong SV::*offset_arg, 
+                       const ulong none_val_arg, 
+                       const ulong default_val_arg, 
+                       const ulong invalid_val_arg,
+                       const struct msl_opts *flags_arg)
+    :sys_var_thd(name_arg), offset(offset_arg), none_val(none_val_arg),
+     default_val(default_val_arg), invalid_val(invalid_val_arg), 
+     flags(flags_arg)
+  { chain_sys_var(chain); }
+  bool check(THD *thd, set_var *var);
+  SHOW_TYPE show_type() { return SHOW_CHAR; }
+  bool check_update_type(Item_result type)
+  {
+    return type != STRING_RESULT;              /* Only accept strings */
+  }
+  void set_default(THD *thd, enum_var_type type);
+  bool update(THD *thd, set_var *var);
+  uchar *value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);
+};
+
+class sys_var_thd_msl_flag_correct_none : public sys_var_thd_msl_flag
+{
+ public:
+  sys_var_thd_msl_flag_correct_none(sys_var_chain *chain, const char *name_arg, ulong SV::*offset_arg,
+				    const ulong none_val_arg,
+				    const ulong default_val_arg,
+				    const ulong invalid_val_arg,
+				    const struct msl_opts *flags_arg)
+    : sys_var_thd_msl_flag(chain,name_arg,offset_arg,none_val_arg,default_val_arg,invalid_val_arg,flags_arg)
+    {
+    }
+  virtual bool update(THD *thd, set_var *var);
+};
+
 class sys_var_thd_storage_engine :public sys_var_thd
 {
 protected:
@@ -1178,8 +1254,9 @@
   ulonglong SV::*offset;
 public:
   sys_var_microseconds(sys_var_chain *chain, const char *name_arg,
-                       ulonglong SV::*offset_arg):
-    sys_var_thd(name_arg), offset(offset_arg)
+                       ulonglong SV::*offset_arg,
+                       Binlog_status_enum binlog_status= NOT_IN_BINLOG):
+  sys_var_thd(name_arg, NULL, binlog_status), offset(offset_arg)
   { chain_sys_var(chain); }
   bool check(THD *thd, set_var *var) {return 0;}
   bool update(THD *thd, set_var *var);
@@ -1470,3 +1547,10 @@
 bool process_key_caches(process_key_cache_t func);
 void delete_elements(I_List<NAMED_LIST> *list,
 		     void (*free_element)(const char*, uchar*));
+
+/* Slow log functions */
+ulong msl_option_resolve_by_name(const struct msl_opts *opts, const char *name, ulong len);
+ulong msl_flag_resolve_by_name(const struct msl_opts *opts, const char *names_list, 
+                               const ulong none_val, const ulong invalid_val);
+const char *msl_option_get_name(const struct msl_opts *opts, ulong val);
+char *msl_flag_get_name(const struct msl_opts *opts, char *buf, ulong val);
--- a/sql/slave.cc
+++ b/sql/slave.cc
@@ -1836,6 +1836,7 @@
     + MAX_LOG_EVENT_HEADER;  /* note, incr over the global not session var */
   thd->slave_thread = 1;
   thd->enable_slow_log= opt_log_slow_slave_statements;
+  thd->write_to_slow_log= opt_log_slow_slave_statements;
   set_slave_thread_options(thd);
   thd->client_capabilities = CLIENT_LOCAL_FILES;
   pthread_mutex_lock(&LOCK_thread_count);
--- a/sql/sp_head.cc
+++ b/sql/sp_head.cc
@@ -1989,7 +1989,7 @@
     DBUG_PRINT("info",(" %.*s: eval args done", (int) m_name.length, 
                        m_name.str));
   }
-  if (!(m_flags & LOG_SLOW_STATEMENTS) && thd->enable_slow_log)
+  if (!(m_flags & LOG_SLOW_STATEMENTS || opt_log_slow_sp_statements) && thd->enable_slow_log)
   {
     DBUG_PRINT("info", ("Disabling slow log for the execution"));
     save_enable_slow_log= true;
--- a/sql/sql_cache.cc
+++ b/sql/sql_cache.cc
@@ -1706,6 +1706,7 @@
 
   thd->limit_found_rows = query->found_rows();
   thd->status_var.last_query_cost= 0.0;
+  thd->query_plan_flags|= QPLAN_QC;
   if (!thd->main_da.is_set())
     thd->main_da.disable_status();
 
@@ -1715,6 +1716,7 @@
 err_unlock:
   unlock();
 err:
+  thd->query_plan_flags|= QPLAN_QC_NO;
   DBUG_RETURN(0);				// Query was not cached
 }
 
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -342,6 +342,37 @@
   thd->row_count++;
 }
 
+extern "C"
+void increment_thd_innodb_stats(THD* thd,
+                    unsigned long long trx_id,
+                    long io_reads,
+                    long long  io_read,
+                    long      io_reads_wait_timer,
+                    long      lock_que_wait_timer,
+                    long      que_wait_timer,
+                    long      page_access)
+{
+  thd->innodb_was_used = TRUE;
+  thd->innodb_trx_id = trx_id;
+  thd->innodb_io_reads += io_reads;
+  thd->innodb_io_read += io_read;
+  thd->innodb_io_reads_wait_timer += io_reads_wait_timer;
+  thd->innodb_lock_que_wait_timer += lock_que_wait_timer;
+  thd->innodb_innodb_que_wait_timer += que_wait_timer;
+  thd->innodb_page_access += page_access;
+}
+
+extern "C"
+unsigned long thd_log_slow_verbosity(const THD *thd)
+{
+  return (unsigned long) thd->variables.log_slow_verbosity;
+}
+
+extern "C"
+int thd_opt_slow_log()
+{
+  return (int) opt_slow_log;
+}
 
 /**
   Dumps a text description of a thread, its security context
@@ -761,6 +792,8 @@
 bool THD::handle_error(uint sql_errno, const char *message,
                        MYSQL_ERROR::enum_warning_level level)
 {
+  last_errno = sql_errno;
+
   for (Internal_error_handler *error_handler= m_internal_handler;
        error_handler;
        error_handler= error_handler->m_prev_internal_handler)
@@ -3196,6 +3229,12 @@
     first_successful_insert_id_in_prev_stmt;
   backup->first_successful_insert_id_in_cur_stmt= 
     first_successful_insert_id_in_cur_stmt;
+  backup->innodb_io_reads= innodb_io_reads;
+  backup->innodb_io_read= innodb_io_read;
+  backup->innodb_io_reads_wait_timer= innodb_io_reads_wait_timer;
+  backup->innodb_lock_que_wait_timer= innodb_lock_que_wait_timer;
+  backup->innodb_innodb_que_wait_timer= innodb_innodb_que_wait_timer;
+  backup->innodb_page_access= innodb_page_access;
 
   if ((!lex->requires_prelocking() || is_update_query(lex->sql_command)) &&
       !current_stmt_binlog_row_based)
@@ -3215,6 +3254,14 @@
   cuted_fields= 0;
   transaction.savepoints= 0;
   first_successful_insert_id_in_cur_stmt= 0;
+  last_errno= 0;
+  innodb_trx_id= 0;
+  innodb_io_reads= 0;
+  innodb_io_read= 0;
+  innodb_io_reads_wait_timer= 0;
+  innodb_lock_que_wait_timer= 0;
+  innodb_innodb_que_wait_timer= 0;
+  innodb_page_access= 0;
 }
 
 
@@ -3277,6 +3324,12 @@
   */
   examined_row_count+= backup->examined_row_count;
   cuted_fields+=       backup->cuted_fields;
+  innodb_io_reads+= backup->innodb_io_reads;
+  innodb_io_read+= backup->innodb_io_read;
+  innodb_io_reads_wait_timer+= backup->innodb_io_reads_wait_timer;
+  innodb_lock_que_wait_timer+= backup->innodb_lock_que_wait_timer;
+  innodb_innodb_que_wait_timer+= backup->innodb_innodb_que_wait_timer;
+  innodb_page_access+= backup->innodb_page_access;
   DBUG_VOID_RETURN;
 }
 
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -404,6 +404,21 @@
   DATE_TIME_FORMAT *datetime_format;
   DATE_TIME_FORMAT *time_format;
   my_bool sysdate_is_now;
+
+#ifndef DBUG_OFF
+  ulonglong query_exec_time;
+#endif
+  ulong log_slow_rate_limit;
+  ulong log_slow_filter;
+  ulong log_slow_verbosity;
+  ulong use_global_log_slow_control;
+
+  ulong      innodb_io_reads;
+  ulonglong  innodb_io_read;
+  ulong      innodb_io_reads_wait_timer;
+  ulong      innodb_lock_que_wait_timer;
+  ulong      innodb_innodb_que_wait_timer;
+  ulong      innodb_page_access;
 };
 
 
@@ -1000,6 +1015,14 @@
   uint in_sub_stmt;
   bool enable_slow_log;
   bool last_insert_id_used;
+
+  ulong      innodb_io_reads;
+  ulonglong  innodb_io_read;
+  ulong      innodb_io_reads_wait_timer;
+  ulong      innodb_lock_que_wait_timer;
+  ulong      innodb_innodb_que_wait_timer;
+  ulong      innodb_page_access;
+
   SAVEPOINT *savepoints;
   enum enum_check_fields count_cuted_fields;
 };
@@ -1427,6 +1450,26 @@
   thr_lock_type update_lock_default;
   Delayed_insert *di;
 
+  bool       write_to_slow_log;
+
+  ulonglong  bytes_sent_old;
+  ulong      tmp_tables_used;
+  ulong      tmp_tables_disk_used;
+  ulonglong  tmp_tables_size;
+  bool       innodb_was_used;
+  ulonglong  innodb_trx_id;
+  ulong      innodb_io_reads;
+  ulonglong  innodb_io_read;
+  ulong      innodb_io_reads_wait_timer;
+  ulong      innodb_lock_que_wait_timer;
+  ulong      innodb_innodb_que_wait_timer;
+  ulong      innodb_page_access;
+
+  ulong      query_plan_flags;
+  ulong      query_plan_fsort_passes;
+
+  uint       last_errno;
+
   /* <> 0 if we are inside of trigger or stored function. */
   uint in_sub_stmt;
   /* TRUE when the current top has SQL_LOG_BIN ON */
@@ -1772,6 +1815,11 @@
     create_sort_index(); may differ from examined_row_count.
   */
   ulong      row_count;
+  /*
+    Original row_count value at the start of query execution
+    (used by the slow_extended patch).
+  */
+  ulong      orig_row_count;
   pthread_t  real_id;                           /* For debugging */
   my_thread_id  thread_id;
   uint	     tmp_table, global_read_lock;
--- a/sql/sql_connect.cc
+++ b/sql/sql_connect.cc
@@ -1421,6 +1421,15 @@
     if (login_connection(thd))
       goto end_thread;
 
+    /* 
+      If rate limiting of slow log writes is enabled, decide whether to log this 
+      new thread's queries or not. Uses extremely simple algorithm. :) 
+    */ 
+    thd->write_to_slow_log= FALSE; 
+    if (thd->variables.log_slow_rate_limit <= 1 ||  
+        (thd->thread_id % thd->variables.log_slow_rate_limit) == 0) 
+         thd->write_to_slow_log= TRUE; 
+
     prepare_new_connection_state(thd);
 
     while (!net->error && net->vio != 0 &&
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -48,6 +48,7 @@
 
 static bool execute_sqlcom_select(THD *thd, TABLE_LIST *all_tables);
 static bool check_show_create_table_access(THD *thd, TABLE_LIST *table);
+static inline ulonglong get_query_exec_time(THD *thd, ulonglong cur_utime);
 
 const char *any_db="*any*";	// Special symbol for check_access
 
@@ -1702,6 +1703,50 @@
   DBUG_RETURN(error);
 }
 
+/**
+   Calculate execution time for the current query.
+
+   For debug builds, check the session value of query_exec_time
+   and if it is not zero, return it instead of the actual execution time.
+
+   SET queries are ignored so that statements changing query_exec_time are not
+   affected by themselves.
+
+   @param thd              thread handle
+   @param lex              current relative time in microseconds
+
+   @return                 time in microseconds from utime_after_lock
+*/
+
+static inline ulonglong get_query_exec_time(THD *thd, ulonglong cur_utime)
+{
+#ifndef DBUG_OFF
+  if (thd->variables.query_exec_time)
+    return thd->lex->sql_command != SQLCOM_SET_OPTION ?
+      thd->variables.query_exec_time : 0;
+#endif
+
+  return cur_utime - thd->utime_after_lock;
+}
+
+
+static inline void copy_global_to_session(THD *thd, ulong flag,
+                                          const ulong *val)
+{
+  my_ptrdiff_t offset = ((char *)val - (char *)&global_system_variables);
+  if (global_system_variables.use_global_log_slow_control & flag)
+    *(ulong *)((char *) &thd->variables + offset) = *val;
+}
+
+
+static inline void copy_global_to_session(THD *thd, ulong flag,
+                                          const ulonglong *val)
+{
+  my_ptrdiff_t offset = ((char *)val - (char *)&global_system_variables);
+  if (global_system_variables.use_global_log_slow_control & flag)
+    *(ulonglong *)((char *) &thd->variables + offset) = *val;
+}
+
 
 void log_slow_statement(THD *thd)
 {
@@ -1715,17 +1760,51 @@
   if (unlikely(thd->in_sub_stmt))
     DBUG_VOID_RETURN;                           // Don't set time for sub stmt
 
+  /* Follow the slow log filter configuration. */
+  if (thd->variables.log_slow_filter != SLOG_F_NONE &&
+      (!(thd->variables.log_slow_filter & thd->query_plan_flags) ||
+       ((thd->variables.log_slow_filter & SLOG_F_QC_NO) &&
+        (thd->query_plan_flags & QPLAN_QC))))
+    DBUG_VOID_RETURN;
+
+  ulonglong end_utime_of_query= thd->current_utime();
+  ulonglong query_exec_time= get_query_exec_time(thd, end_utime_of_query);
+
+  /*
+    Low long_query_time value most likely means user is debugging stuff and even
+    though some thread's queries are not supposed to be logged b/c of the rate
+    limit, if one of them takes long enough (>= 1 second) it will be sensible
+    to make an exception and write to slow log anyway.
+  */
+
+  /* use_global_log_slow_control */
+  system_variables const &g= global_system_variables;
+  copy_global_to_session(thd, SLOG_UG_LOG_SLOW_FILTER,
+                         &g.log_slow_filter);
+  copy_global_to_session(thd, SLOG_UG_LOG_SLOW_RATE_LIMIT,
+                         &g.log_slow_rate_limit);
+  copy_global_to_session(thd, SLOG_UG_LOG_SLOW_VERBOSITY,
+                         &g.log_slow_verbosity);
+  copy_global_to_session(thd, SLOG_UG_LONG_QUERY_TIME,
+                         &g.long_query_time);
+  copy_global_to_session(thd, SLOG_UG_MIN_EXAMINED_ROW_LIMIT,
+                         &g.min_examined_row_limit);
+
+  /* Do not log this thread's queries due to rate limiting. */
+  if (thd->write_to_slow_log != TRUE
+      && (thd->variables.long_query_time >= 1000000
+          || (ulong) query_exec_time < 1000000))
+    DBUG_VOID_RETURN;
+
   /*
     Do not log administrative statements unless the appropriate option is
     set.
   */
   if (thd->enable_slow_log)
   {
-    ulonglong end_utime_of_query= thd->current_utime();
     thd_proc_info(thd, "logging slow query");
 
-    if (((end_utime_of_query - thd->utime_after_lock) >
-         thd->variables.long_query_time ||
+    if (((query_exec_time > thd->variables.long_query_time) ||
          ((thd->server_status &
            (SERVER_QUERY_NO_INDEX_USED | SERVER_QUERY_NO_GOOD_INDEX_USED)) &&
           opt_log_queries_not_using_indexes &&
@@ -2101,6 +2180,9 @@
     context.resolve_in_table_list_only(select_lex->
                                        table_list.first);
 
+  /* Save the original row_count value for extended stats in slow query log */
+  thd->orig_row_count= thd->row_count;
+
   /*
     Reset warning count for each query that uses tables
     A better approach would be to reset this for any commands
@@ -5829,6 +5911,21 @@
   thd->rand_used= 0;
   thd->sent_row_count= thd->examined_row_count= 0;
 
+  thd->bytes_sent_old= thd->status_var.bytes_sent;
+  thd->tmp_tables_used= thd->tmp_tables_disk_used= 0;
+  thd->tmp_tables_size= 0;
+  thd->innodb_was_used= FALSE;
+  thd->innodb_trx_id= 0;
+  thd->innodb_io_reads= 0;
+  thd->innodb_io_read= 0;
+  thd->innodb_io_reads_wait_timer= 0;
+  thd->innodb_lock_que_wait_timer= 0;
+  thd->innodb_innodb_que_wait_timer= 0;
+  thd->innodb_page_access= 0;
+  thd->query_plan_flags= QPLAN_NONE;
+  thd->query_plan_fsort_passes= 0;
+  thd->last_errno= 0;
+
   /*
     Because we come here only for start of top-statements, binlog format is
     constant inside a complex statement (using stored functions) etc.
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -6798,7 +6798,10 @@
 	  {
 	    join->thd->server_status|=SERVER_QUERY_NO_INDEX_USED;
 	    if (statistics)
+            {
 	      status_var_increment(join->thd->status_var.select_scan_count);
+              join->thd->query_plan_flags|= QPLAN_FULL_SCAN;
+            }
 	  }
 	}
 	else
@@ -6812,7 +6815,10 @@
 	  {
 	    join->thd->server_status|=SERVER_QUERY_NO_INDEX_USED;
 	    if (statistics)
+            {
 	      status_var_increment(join->thd->status_var.select_full_join_count);
+              join->thd->query_plan_flags|= QPLAN_FULL_JOIN;
+            }
 	  }
 	}
 	if (!table->no_keyread)
@@ -10016,6 +10022,7 @@
               (ulong) rows_limit,test(group)));
 
   status_var_increment(thd->status_var.created_tmp_tables);
+  thd->query_plan_flags|= QPLAN_TMP_TABLE;
 
   if (use_temp_pool && !(test_flags & TEST_KEEP_TMP_TABLES))
     temp_pool_slot = bitmap_lock_set_next(&temp_pool);
@@ -10897,6 +10904,7 @@
     goto err;
   }
   status_var_increment(table->in_use->status_var.created_tmp_disk_tables);
+  table->in_use->query_plan_flags|= QPLAN_TMP_DISK;
   share->db_record_offset= 1;
   DBUG_RETURN(0);
  err:
@@ -10915,6 +10923,14 @@
   save_proc_info=thd->proc_info;
   thd_proc_info(thd, "removing tmp table");
 
+  thd->tmp_tables_used++;
+  if (entry->file)
+  {
+    thd->tmp_tables_size += entry->file->stats.data_file_length;
+    if (entry->file->ht->db_type != DB_TYPE_HEAP)
+      thd->tmp_tables_disk_used++;
+  }
+
   // Release latches since this can take a long time
   ha_release_temporary_latches(thd);
 
--- a/sql/sql_show.cc
+++ b/sql/sql_show.cc
@@ -1971,8 +1971,17 @@
         table->field[4]->store(command_name[tmp->command].str,
                                command_name[tmp->command].length, cs);
       /* MYSQL_TIME */
-      table->field[5]->store((longlong)(tmp->start_time ?
-                                      now - tmp->start_time : 0), FALSE);
+      longlong value_in_time_column= 0;
+      if(tmp->start_time)
+      {
+        value_in_time_column = (now - tmp->start_time);
+        if(value_in_time_column > now)
+        {
+          value_in_time_column= 0;
+        }
+      }
+      table->field[5]->store(value_in_time_column, FALSE);
+
       /* STATE */
 #ifndef EMBEDDED_LIBRARY
       val= (char*) (tmp->locked ? "Locked" :
--- /dev/null
+++ b/mysql-test/include/log_grep.inc
@@ -0,0 +1,17 @@
+--disable_query_log
+--echo [log_grep.inc] file: $log_file pattern: $grep_pattern
+perl;
+  $log_file=           $ENV{'log_file'};
+  $log_file_full_path= $ENV{'log_file_full_path'};
+  $grep_pattern=       $ENV{'grep_pattern'};
+
+  open(FILE, "$log_file_full_path") 
+    or die("Cannot open file $log_file_full_path: $!\n");
+
+  $lines = 0;
+  while(<FILE>) {
+    $lines++ if (/$grep_pattern/);
+  }
+  close(FILE);
+  print "[log_grep.inc] lines:   $lines\n";
+EOF
--- /dev/null
+++ b/mysql-test/include/log_start.inc
@@ -0,0 +1,16 @@
+--let slow_query_log_file_old=`SELECT Variable_value FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE Variable_name = 'slow_query_log_file';`
+--let slow_query_log_old=`SELECT Variable_value FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE Variable_name = 'slow_query_log';`
+--disable_query_log
+--let log_file_full_path = $MYSQLTEST_VARDIR/$log_file
+SET GLOBAL slow_query_log=0;
+perl;
+  $log_file_full_path= $ENV{'log_file_full_path'};
+  unlink $log_file_full_path;
+  open(FILE, '>', $log_file_full_path)
+    or die "Cannot create log file $log_file_full_path, reason: $!";
+  close(FILE);
+EOF
+--echo [log_start.inc] $log_file
+EVAL SET GLOBAL slow_query_log_file="$log_file_full_path";
+SET GLOBAL slow_query_log=1;
+--enable_query_log
--- /dev/null
+++ b/mysql-test/include/log_stop.inc
@@ -0,0 +1,7 @@
+--disable_query_log
+FLUSH LOGS;
+SET GLOBAL slow_query_log=0;
+--echo [log_stop.inc] $log_file
+EVAL SET GLOBAL slow_query_log_file= "$slow_query_log_file_old";
+EVAL SET GLOBAL slow_query_log=      $slow_query_log_old ;
+--enable_query_log
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_filter-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'log_slow_filter';
+Variable_name	Value
+log_slow_filter	full_join
+SHOW GLOBAL VARIABLES LIKE 'log_slow_filter';
+Variable_name	Value
+log_slow_filter	full_join
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_filter.result
@@ -0,0 +1,15 @@
+CREATE TABLE t(id INT PRIMARY KEY);
+INSERT INTO t VALUES(1);
+INSERT INTO t VALUES(2);
+INSERT INTO t VALUES(3);
+SET long_query_time=1;
+SET log_slow_filter=full_join;
+[log_start.inc] percona.slow_extended.log_slow_filter
+SET query_exec_time = 1.1;
+SELECT * FROM t AS t1, t AS t2;
+SET query_exec_time = default;
+[log_stop.inc] percona.slow_extended.log_slow_filter
+SET log_slow_filter=default;
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.log_slow_filter pattern: Query_time
+[log_grep.inc] lines:   1
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_slave_statements-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'log_slow_slave_statements';
+Variable_name	Value
+log_slow_slave_statements	ON
+SHOW GLOBAL VARIABLES LIKE 'log_slow_slave_statements';
+Variable_name	Value
+log_slow_slave_statements	ON
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_slave_statements-innodb.result
@@ -0,0 +1,18 @@
+include/master-slave.inc
+[connection master]
+DROP TABLE IF EXISTS t;
+CREATE TABLE t(id INT,data CHAR(30)) ENGINE=InnoDB;
+INSERT INTO t VALUES
+(1,"aaaaabbbbbcccccdddddeeeeefffff"),
+(2,"aaaaabbbbbcccccdddddeeeeefffff"),
+(3,"aaaaabbbbbcccccdddddeeeeefffff"),
+(4,"aaaaabbbbbcccccdddddeeeeefffff"),
+(5,"aaaaabbbbbcccccdddddeeeeefffff");
+INSERT INTO t SELECT t2.id,t2.data from t as t1, t as t2;
+INSERT INTO t SELECT t2.id,t2.data from t as t1, t as t2;
+include/rpl_restart_server.inc [server_number=1]
+[log_start.inc] percona.slow_extended.log_slow_slave_statements-innodb
+[log_stop.inc] percona.slow_extended.log_slow_slave_statements-innodb
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements-innodb pattern: InnoDB_IO_r_ops
+[log_grep.inc] lines:   1
+include/rpl_end.inc
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_slave_statements.result
@@ -0,0 +1,46 @@
+include/master-slave.inc
+[connection master]
+DROP TABLE IF EXISTS t;
+CREATE TABLE t(id INT);
+[log_start.inc] percona.slow_extended.log_slow_slave_statements
+LINE 1
+LOG_SLOW_SLAVE_STATAMENTS is OFF
+LOG_SLOW_SLAVE_STATEMENTS=1
+LOG_SLOW_SLAVE_STATAMENTS is ON
+LINE 2
+include/restart_slave.inc
+LOG_SLOW_SLAVE_STATAMENTS is ON
+LINE 3
+LOG_SLOW_SLAVE_STATAMENTS is ON
+LOG_SLOW_SLAVE_STATEMENTS=0
+LOG_SLOW_SLAVE_STATAMENTS is OFF
+LINE 4
+include/restart_slave.inc
+LOG_SLOW_SLAVE_STATAMENTS is OFF
+LINE 5
+LOG_SLOW_SLAVE_STATAMENTS is OFF
+LOG_SLOW_SLAVE_STATEMENTS=1
+LOG_SLOW_SLAVE_STATAMENTS is ON
+LINE 6
+include/restart_slave.inc
+LOG_SLOW_SLAVE_STATAMENTS is ON
+LINE 7
+[log_stop.inc] percona.slow_extended.log_slow_slave_statements
+SET GLOBAL log_slow_slave_statements=default;
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(1\)
+[log_grep.inc] lines:   0
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(2\)
+[log_grep.inc] lines:   0
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(3\)
+[log_grep.inc] lines:   1
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(4\)
+[log_grep.inc] lines:   0
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(5\)
+[log_grep.inc] lines:   0
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(6\)
+[log_grep.inc] lines:   0
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(7\)
+[log_grep.inc] lines:   1
+[log_grep.inc] file: percona.slow_extended.log_slow_slave_statements pattern: INSERT INTO t VALUES \(8\)
+[log_grep.inc] lines:   0
+include/rpl_end.inc
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_sp_statements-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'log_slow_sp_statements';
+Variable_name	Value
+log_slow_sp_statements	ON
+SHOW GLOBAL VARIABLES LIKE 'log_slow_sp_statements';
+Variable_name	Value
+log_slow_sp_statements	ON
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_sp_statements.result
@@ -0,0 +1,22 @@
+SET long_query_time=1;
+SET GLOBAL log_slow_sp_statements=1;
+[log_start.inc] percona.slow_extended.log_slow_sp_statements
+CREATE PROCEDURE test_f()
+BEGIN
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=2.1; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=default;
+END^
+CALL test_f();
+1
+1
+1
+1
+1
+1
+[log_stop.inc] percona.slow_extended.log_slow_sp_statements
+SET GLOBAL log_slow_sp_statements=default;
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.log_slow_sp_statements pattern: Query_time
+[log_grep.inc] lines:   3
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_timestamp_every-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'log_slow_timestamp_every';
+Variable_name	Value
+log_slow_timestamp_every	ON
+SHOW GLOBAL VARIABLES LIKE 'log_slow_timestamp_every';
+Variable_name	Value
+log_slow_timestamp_every	ON
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_timestamp_every.result
@@ -0,0 +1,39 @@
+SET long_query_time=2;
+SET GLOBAL log_slow_timestamp_every=1;
+[log_start.inc] percona.slow_extended.log_slow_timestamp_every
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SELECT 2;
+2
+2
+SELECT 3;
+3
+3
+SET GLOBAL log_slow_timestamp_every=0;
+SELECT 1;
+1
+1
+SELECT 2;
+2
+2
+SELECT 3;
+3
+3
+SET GLOBAL log_slow_timestamp_every=1;
+SELECT 1;
+1
+1
+SELECT 2;
+2
+2
+SELECT 3;
+3
+3
+SET SESSION query_exec_time = default;
+[log_stop.inc] percona.slow_extended.log_slow_timestamp_every
+SET GLOBAL log_slow_timestamp_every=default;
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.log_slow_timestamp_every pattern: # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+
+[log_grep.inc] lines:   6
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_verbosity-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'log_slow_verbosity';
+Variable_name	Value
+log_slow_verbosity	microtime,query_plan,innodb
+SHOW GLOBAL VARIABLES LIKE 'log_slow_verbosity';
+Variable_name	Value
+log_slow_verbosity	microtime,query_plan,innodb
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_verbosity.result
@@ -0,0 +1,16 @@
+SET SESSION long_query_time=1;
+[log_start.inc] percona.slow_extended.log_slow_verbosity
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION log_slow_verbosity=innodb;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=default;
+[log_stop.inc] percona.slow_extended.log_slow_verbosity
+SET log_slow_verbosity='';
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.log_slow_verbosity pattern: No InnoDB statistics available for this query
+[log_grep.inc] lines:   1
--- /dev/null
+++ b/mysql-test/r/percona_long_query_time.result
@@ -0,0 +1,33 @@
+SET long_query_time=2;
+[log_start.inc] percona.slow_extended.long_query_time
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET long_query_time=4;
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=default;
+SET long_query_time=2;
+[log_stop.inc] percona.slow_extended.long_query_time
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.long_query_time pattern: Query_time
+[log_grep.inc] lines:   3
--- /dev/null
+++ b/mysql-test/r/percona_min_examined_row_limit.result
@@ -0,0 +1,34 @@
+drop table if exists t;
+create table t(id INT PRIMARY KEY);
+insert into t values(1);
+insert into t values(2);
+insert into t values(3);
+SET GLOBAL long_query_time=2;
+SET GLOBAL use_global_log_slow_control='long_query_time,min_examined_row_limit';
+[log_start.inc] percona.slow_extended.min_examined_row_limit
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET GLOBAL min_examined_row_limit=5;
+SELECT * FROM t AS t1, t AS t2;
+id	id
+1	1
+2	1
+3	1
+1	2
+2	2
+3	2
+1	3
+2	3
+3	3
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=default;
+[log_stop.inc] percona.slow_extended.min_examined_row_limit
+SET GLOBAL min_examined_row_limit=default;
+SET GLOBAL use_global_log_slow_control='';
+SET GLOBAL long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.min_examined_row_limit pattern: Query_time
+[log_grep.inc] lines:   1
--- /dev/null
+++ b/mysql-test/r/percona_slow_query_log_microseconds_timestamp-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'slow_query_log_microseconds_timestamp';
+Variable_name	Value
+slow_query_log_microseconds_timestamp	ON
+SHOW GLOBAL VARIABLES LIKE 'slow_query_log_microseconds_timestamp';
+Variable_name	Value
+slow_query_log_microseconds_timestamp	ON
--- /dev/null
+++ b/mysql-test/r/percona_slow_query_log_microseconds_timestamp.result
@@ -0,0 +1,18 @@
+SET long_query_time=2;
+[log_start.inc] percona.slow_extended.slow_query_log_microseconds_timestamp
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET GLOBAL slow_query_log_microseconds_timestamp=1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=default;
+[log_stop.inc] percona.slow_extended.slow_query_log_microseconds_timestamp
+SET GLOBAL slow_query_log_microseconds_timestamp=default;
+SET long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.slow_query_log_microseconds_timestamp pattern: # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+.[0-9]+
+[log_grep.inc] lines:   1
+[log_grep.inc] file: percona.slow_extended.slow_query_log_microseconds_timestamp pattern: # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+
+[log_grep.inc] lines:   2
--- /dev/null
+++ b/mysql-test/r/percona_use_global_log_slow_control-cl.result
@@ -0,0 +1,6 @@
+SHOW VARIABLES LIKE 'use_global_log_slow_control';
+Variable_name	Value
+use_global_log_slow_control	log_slow_verbosity,long_query_time
+SHOW GLOBAL VARIABLES LIKE 'use_global_log_slow_control';
+Variable_name	Value
+use_global_log_slow_control	log_slow_verbosity,long_query_time
--- /dev/null
+++ b/mysql-test/r/percona_use_global_log_slow_control.result
@@ -0,0 +1,18 @@
+SET GLOBAL long_query_time=1;
+[log_start.inc] percona.slow_extended.use_global_log_slow_control
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET GLOBAL log_slow_verbosity=innodb;
+SET GLOBAL use_global_log_slow_control="log_slow_verbosity,long_query_time";
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=default;
+[log_stop.inc] percona.slow_extended.use_global_log_slow_control
+SET GLOBAL use_global_log_slow_control='';
+SET GLOBAL log_slow_verbosity='';
+SET GLOBAL long_query_time=default;
+[log_grep.inc] file: percona.slow_extended.use_global_log_slow_control pattern: No InnoDB statistics available for this query
+[log_grep.inc] lines:   1
--- /dev/null
+++ b/mysql-test/r/percona_use_global_long_query_time.result
@@ -0,0 +1,34 @@
+[log_start.inc] percona.slow_extended.use_global_long_query_time
+SET long_query_time=2;
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET GLOBAL long_query_time=4;
+SET GLOBAL use_global_long_query_time=1;
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0;
+[log_stop.inc] percona.slow_extended.use_global_long_query_time
+SET GLOBAL long_query_time=default;
+SET GLOBAL use_global_long_query_time=0;
+[log_grep.inc] file: percona.slow_extended.use_global_long_query_time pattern: Query_time
+[log_grep.inc] lines:   3
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_filter-cl-master.opt
@@ -0,0 +1 @@
+--log_slow_filter=full_join
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_filter-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'log_slow_filter';
+SHOW GLOBAL VARIABLES LIKE 'log_slow_filter';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_filter.test
@@ -0,0 +1,26 @@
+--source include/have_debug.inc
+
+CREATE TABLE t(id INT PRIMARY KEY);
+INSERT INTO t VALUES(1);
+INSERT INTO t VALUES(2);
+INSERT INTO t VALUES(3);
+
+SET long_query_time=1;
+SET log_slow_filter=full_join;
+--let log_file=percona.slow_extended.log_slow_filter
+--source include/log_start.inc
+
+SET query_exec_time = 1.1;
+--disable_result_log
+SELECT * FROM t AS t1, t AS t2;
+--enable_result_log
+SET query_exec_time = default;
+
+--source include/log_stop.inc
+SET log_slow_filter=default;
+SET long_query_time=default;
+
+--let grep_pattern = Query_time
+--source include/log_grep.inc
+
+DROP TABLE t;
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements-cl-master.opt
@@ -0,0 +1 @@
+--log_slow_slave_statements
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements-cl.test
@@ -0,0 +1,3 @@
+SHOW VARIABLES LIKE 'log_slow_slave_statements';
+SHOW GLOBAL VARIABLES LIKE 'log_slow_slave_statements';
+
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements-innodb-slave.opt
@@ -0,0 +1 @@
+--long_query_time=0 --log_slow_slave_statements --log_slow_verbosity=innodb
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements-innodb.test
@@ -0,0 +1,48 @@
+--source include/have_binlog_format_statement.inc
+--source include/master-slave.inc
+--source include/have_innodb.inc
+--let log_file=percona.slow_extended.log_slow_slave_statements-innodb
+
+connection master;
+-- disable_warnings
+DROP TABLE IF EXISTS t;
+-- enable_warnings
+
+CREATE TABLE t(id INT,data CHAR(30)) ENGINE=InnoDB;
+INSERT INTO t VALUES
+(1,"aaaaabbbbbcccccdddddeeeeefffff"),
+(2,"aaaaabbbbbcccccdddddeeeeefffff"),
+(3,"aaaaabbbbbcccccdddddeeeeefffff"),
+(4,"aaaaabbbbbcccccdddddeeeeefffff"),
+(5,"aaaaabbbbbcccccdddddeeeeefffff");
+INSERT INTO t SELECT t2.id,t2.data from t as t1, t as t2;
+INSERT INTO t SELECT t2.id,t2.data from t as t1, t as t2;
+sync_slave_with_master;
+
+--let rpl_server_number=1
+--source include/rpl_restart_server.inc
+
+connection slave;
+--source include/log_start.inc
+
+--disable_query_log
+--disable_result_log
+
+connection master;
+INSERT INTO t SELECT t.id,t.data from t;
+sync_slave_with_master;
+
+connection slave;
+--source include/log_stop.inc
+
+--enable_query_log
+--enable_result_log
+
+--let grep_pattern =  InnoDB_IO_r_ops
+--source include/log_grep.inc
+
+connection master;
+DROP TABLE t;
+sync_slave_with_master;
+
+--source include/rpl_end.inc
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements-slave.opt
@@ -0,0 +1 @@
+--long_query_time=0
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_slave_statements.test
@@ -0,0 +1,119 @@
+-- source include/have_binlog_format_statement.inc
+-- source include/master-slave.inc
+--let log_file=percona.slow_extended.log_slow_slave_statements
+--let show=SELECT Variable_value FROM INFORMATION_SCHEMA.SESSION_VARIABLES WHERE Variable_name LIKE 'log_slow_slave_statements';
+
+connection master;
+-- disable_warnings
+DROP TABLE IF EXISTS t;
+-- enable_warnings
+
+CREATE TABLE t(id INT);
+sync_slave_with_master;
+
+connection slave;
+--source include/log_start.inc
+
+--disable_query_log
+--disable_result_log
+
+--echo LINE 1
+connection master;
+INSERT INTO t VALUES (1);
+sync_slave_with_master;
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+--echo LOG_SLOW_SLAVE_STATEMENTS=1
+SET GLOBAL log_slow_slave_statements=1;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 2
+connection master;
+INSERT INTO t VALUES (2);
+sync_slave_with_master;
+
+--source include/restart_slave_sql.inc
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 3
+connection master;
+INSERT INTO t VALUES (3);
+sync_slave_with_master;
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+--echo LOG_SLOW_SLAVE_STATEMENTS=0
+SET GLOBAL log_slow_slave_statements=0;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 4
+connection master;
+INSERT INTO t VALUES (4);
+sync_slave_with_master;
+
+--source include/restart_slave_sql.inc
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 5
+connection master;
+INSERT INTO t VALUES (5);
+sync_slave_with_master;
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+--echo LOG_SLOW_SLAVE_STATEMENTS=1
+SET GLOBAL log_slow_slave_statements=1;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 6
+connection master;
+INSERT INTO t VALUES (6);
+sync_slave_with_master;
+
+--source include/restart_slave_sql.inc
+
+connection slave;
+--let value=`$show`
+--echo LOG_SLOW_SLAVE_STATAMENTS is $value
+
+--echo LINE 7
+connection master;
+INSERT INTO t VALUES (7);
+sync_slave_with_master;
+
+--enable_query_log
+--enable_result_log
+
+connection slave;
+--source include/log_stop.inc
+SET GLOBAL log_slow_slave_statements=default;
+
+connection slave;
+--let i=1
+--let k=8
+while($k)
+{
+--let grep_pattern= INSERT INTO t VALUES \($i\)
+--source include/log_grep.inc
+  inc $i;
+  dec $k;
+}
+
+connection master;
+DROP TABLE t;
+sync_slave_with_master;
+
+--source include/rpl_end.inc
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_sp_statements-cl-master.opt
@@ -0,0 +1 @@
+--log_slow_sp_statements
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_sp_statements-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'log_slow_sp_statements';
+SHOW GLOBAL VARIABLES LIKE 'log_slow_sp_statements';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_sp_statements.test
@@ -0,0 +1,27 @@
+--source include/have_debug.inc
+
+SET long_query_time=1;
+SET GLOBAL log_slow_sp_statements=1;
+--let log_file=percona.slow_extended.log_slow_sp_statements
+--source include/log_start.inc
+
+delimiter ^;
+CREATE PROCEDURE test_f()
+BEGIN
+  SET SESSION query_exec_time=1.1; SELECT 1;
+  SET SESSION query_exec_time=2.1; SELECT 1;
+  SET SESSION query_exec_time=3.1; SELECT 1;
+  SET SESSION query_exec_time=default;
+END^
+delimiter ;^	
+
+CALL test_f();
+
+--source include/log_stop.inc
+SET GLOBAL log_slow_sp_statements=default;
+SET long_query_time=default;
+
+--let grep_pattern = Query_time
+--source include/log_grep.inc
+
+DROP PROCEDURE test_f;
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_timestamp_every-cl-master.opt
@@ -0,0 +1 @@
+--log_slow_timestamp_every
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_timestamp_every-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'log_slow_timestamp_every';
+SHOW GLOBAL VARIABLES LIKE 'log_slow_timestamp_every';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_timestamp_every.test
@@ -0,0 +1,33 @@
+--source include/have_debug.inc
+
+SET long_query_time=2;
+SET GLOBAL log_slow_timestamp_every=1;
+--let log_file=percona.slow_extended.log_slow_timestamp_every
+--source include/log_start.inc
+
+SET SESSION query_exec_time=2.1;
+
+SELECT 1;
+SELECT 2;
+SELECT 3;
+
+SET GLOBAL log_slow_timestamp_every=0;
+
+SELECT 1;
+SELECT 2;
+SELECT 3;
+
+SET GLOBAL log_slow_timestamp_every=1;
+
+SELECT 1;
+SELECT 2;
+SELECT 3;
+
+SET SESSION query_exec_time = default;
+
+--source include/log_stop.inc
+SET GLOBAL log_slow_timestamp_every=default;
+SET long_query_time=default;
+
+--let grep_pattern =  # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+
+--source include/log_grep.inc
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_verbosity-cl-master.opt
@@ -0,0 +1 @@
+--log_slow_verbosity="full"
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_verbosity-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'log_slow_verbosity';
+SHOW GLOBAL VARIABLES LIKE 'log_slow_verbosity';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_verbosity.test
@@ -0,0 +1,19 @@
+--source include/have_innodb.inc
+--source include/have_debug.inc
+
+SET SESSION long_query_time=1;
+--let log_file=percona.slow_extended.log_slow_verbosity
+--source include/log_start.inc
+
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+SET SESSION log_slow_verbosity=innodb; 
+SELECT 1;
+SET SESSION query_exec_time=default;
+
+--source include/log_stop.inc
+SET log_slow_verbosity='';
+SET long_query_time=default;
+
+--let grep_pattern = No InnoDB statistics available for this query
+--source include/log_grep.inc
--- /dev/null
+++ b/mysql-test/t/percona_long_query_time.test
@@ -0,0 +1,25 @@
+--source include/have_debug.inc
+
+SET long_query_time=2;
+--let log_file=percona.slow_extended.long_query_time
+--source include/log_start.inc
+
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=5.1; SELECT 1;
+
+SET long_query_time=4;
+
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=5.1; SELECT 1;
+
+SET SESSION query_exec_time=default;
+
+SET long_query_time=2;
+
+--source include/log_stop.inc
+SET long_query_time=default;
+
+--let grep_pattern = Query_time
+--source include/log_grep.inc
--- /dev/null
+++ b/mysql-test/t/percona_min_examined_row_limit.test
@@ -0,0 +1,35 @@
+--source include/have_debug.inc
+
+--disable_warnings
+drop table if exists t;
+--enable_warnings
+
+create table t(id INT PRIMARY KEY);
+insert into t values(1);
+insert into t values(2);
+insert into t values(3);
+
+SET GLOBAL long_query_time=2;
+SET GLOBAL use_global_log_slow_control='long_query_time,min_examined_row_limit';
+--let log_file=percona.slow_extended.min_examined_row_limit
+--source include/log_start.inc
+
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+
+SET GLOBAL min_examined_row_limit=5;
+
+SELECT * FROM t AS t1, t AS t2;
+SELECT 1;
+
+SET SESSION query_exec_time=default;
+
+--source include/log_stop.inc
+SET GLOBAL min_examined_row_limit=default;
+SET GLOBAL use_global_log_slow_control='';
+SET GLOBAL long_query_time=default;
+
+--let grep_pattern = Query_time
+--source include/log_grep.inc
+
+DROP TABLE t;
--- /dev/null
+++ b/mysql-test/t/percona_slow_query_log_microseconds_timestamp-cl-master.opt
@@ -0,0 +1 @@
+--slow_query_log_microseconds_timestamp
--- /dev/null
+++ b/mysql-test/t/percona_slow_query_log_microseconds_timestamp-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'slow_query_log_microseconds_timestamp';
+SHOW GLOBAL VARIABLES LIKE 'slow_query_log_microseconds_timestamp';
--- /dev/null
+++ b/mysql-test/t/percona_slow_query_log_microseconds_timestamp-master.opt
@@ -0,0 +1 @@
+--log_slow_timestamp_every
--- /dev/null
+++ b/mysql-test/t/percona_slow_query_log_microseconds_timestamp.test
@@ -0,0 +1,25 @@
+--source include/have_debug.inc
+
+SET long_query_time=2;
+--let log_file=percona.slow_extended.slow_query_log_microseconds_timestamp
+--source include/log_start.inc
+
+SET SESSION query_exec_time=2.1;
+
+SELECT 1;
+
+SET GLOBAL slow_query_log_microseconds_timestamp=1;
+
+SELECT 1;
+
+SET SESSION query_exec_time=default;
+
+--source include/log_stop.inc
+SET GLOBAL slow_query_log_microseconds_timestamp=default;
+SET long_query_time=default;
+
+--let grep_pattern = # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+.[0-9]+
+--source include/log_grep.inc
+
+--let grep_pattern =  # Time: [0-9]+[ ]+[0-9]+:[0-9]+:[0-9]+
+--source include/log_grep.inc
--- /dev/null
+++ b/mysql-test/t/percona_use_global_log_slow_control-cl-master.opt
@@ -0,0 +1 @@
+--use_global_log_slow_control="log_slow_verbosity,long_query_time"
--- /dev/null
+++ b/mysql-test/t/percona_use_global_log_slow_control-cl.test
@@ -0,0 +1,2 @@
+SHOW VARIABLES LIKE 'use_global_log_slow_control';
+SHOW GLOBAL VARIABLES LIKE 'use_global_log_slow_control';
--- /dev/null
+++ b/mysql-test/t/percona_use_global_log_slow_control.test
@@ -0,0 +1,28 @@
+--source include/have_debug.inc
+--source include/have_innodb.inc
+
+SET GLOBAL long_query_time=1;
+
+--let log_file=percona.slow_extended.use_global_log_slow_control
+--source include/log_start.inc
+
+SET SESSION query_exec_time=1.1;
+
+SELECT 1;
+
+SET GLOBAL log_slow_verbosity=innodb;
+SET GLOBAL use_global_log_slow_control="log_slow_verbosity,long_query_time";
+
+SELECT 1;
+
+SET SESSION query_exec_time=default;
+
+--source include/log_stop.inc
+
+SET GLOBAL use_global_log_slow_control='';
+SET GLOBAL log_slow_verbosity='';
+SET GLOBAL long_query_time=default;
+
+--let grep_pattern = No InnoDB statistics available for this query
+--source include/log_grep.inc
+
--- /dev/null
+++ b/mysql-test/t/percona_use_global_long_query_time.test
@@ -0,0 +1,27 @@
+--source include/have_debug.inc
+
+--let log_file=percona.slow_extended.use_global_long_query_time
+--source include/log_start.inc
+
+SET long_query_time=2;
+
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=5.1; SELECT 1;
+
+SET GLOBAL long_query_time=4;
+SET GLOBAL use_global_long_query_time=1;
+
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=5.1; SELECT 1;
+
+SET SESSION query_exec_time=0;
+
+--source include/log_stop.inc
+
+SET GLOBAL long_query_time=default;
+SET GLOBAL use_global_long_query_time=0;
+
+--let grep_pattern = Query_time
+--source include/log_grep.inc
--- a/sql/log_event.h
+++ b/sql/log_event.h
@@ -338,6 +338,10 @@
 
 #define Q_INVOKER 11
 
+#ifndef DBUG_OFF
+#define Q_QUERY_EXEC_TIME 250
+#endif
+
 /* Intvar event post-header */
 
 /* Intvar event data */
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_admin_statements.result
@@ -0,0 +1,6 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+Variable_name	Value
+log_slow_admin_statements	OFF
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
+VARIABLE_NAME	VARIABLE_VALUE
+LOG_SLOW_ADMIN_STATEMENTS	OFF
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements.test
@@ -0,0 +1,2 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_admin_statements-config_false.result
@@ -0,0 +1,6 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+Variable_name	Value
+log_slow_admin_statements	OFF
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
+VARIABLE_NAME	VARIABLE_VALUE
+LOG_SLOW_ADMIN_STATEMENTS	OFF
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_admin_statements-config_foo.result
@@ -0,0 +1,7 @@
+call mtr.add_suppression("ignoring option '--log-slow-admin-statements' due to invalid value 'foo'");
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+Variable_name	Value
+log_slow_admin_statements	OFF
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
+VARIABLE_NAME	VARIABLE_VALUE
+LOG_SLOW_ADMIN_STATEMENTS	OFF
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_admin_statements-config_true.result
@@ -0,0 +1,6 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+Variable_name	Value
+log_slow_admin_statements	ON
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
+VARIABLE_NAME	VARIABLE_VALUE
+LOG_SLOW_ADMIN_STATEMENTS	ON
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_false.cnf
@@ -0,0 +1,2 @@
+[mysqld.1]
+log-slow-admin-statements=false
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_false.test
@@ -0,0 +1,2 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_foo.cnf
@@ -0,0 +1,2 @@
+[mysqld.1]
+log-slow-admin-statements=foo
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_foo.test
@@ -0,0 +1,3 @@
+call mtr.add_suppression("ignoring option '--log-slow-admin-statements' due to invalid value 'foo'");
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_true.cnf
@@ -0,0 +1,2 @@
+[mysqld.1]
+log-slow-admin-statements=true
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config_true.test
@@ -0,0 +1,2 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
--- /dev/null
+++ b/mysql-test/r/percona_log_slow_admin_statements-config.result
@@ -0,0 +1,6 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+Variable_name	Value
+log_slow_admin_statements	ON
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
+VARIABLE_NAME	VARIABLE_VALUE
+LOG_SLOW_ADMIN_STATEMENTS	ON
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config.cnf
@@ -0,0 +1,2 @@
+[mysqld.1]
+log-slow-admin-statements
--- /dev/null
+++ b/mysql-test/t/percona_log_slow_admin_statements-config.test
@@ -0,0 +1,2 @@
+SHOW GLOBAL VARIABLES like 'log_slow_admin_statements';
+SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME='log_slow_admin_statements';
